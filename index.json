[{"authors":null,"categories":null,"content":"I am a third-year undergraduate student in the Department of Computer Science at Peking University. My research interests span generally in programming languages, especially type systems, functional programming, bidirectional transformation and program calculation.\nI am currently advised by Prof. Zhenjiang Hu and I am an intern in the Programing Language Group of Peking University.\n Download my resumÃ©. -- ","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"thwfhk.github.io/author/wenhao-tang/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"thwfhk.github.io/author/wenhao-tang/","section":"authors","summary":"I am a third-year undergraduate student in the Department of Computer Science at Peking University. My research interests span generally in programming languages, especially type systems, functional programming, bidirectional transformation and program calculation.","tags":null,"title":"Wenhao Tang","type":"authors"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature.   Slides can be added in a few ways:\n Create slides using Wowchemy\u0026rsquo;s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further event details, including page elements such as image galleries, can be added to the body of this page.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1906549200,"objectID":"96344c08df50a1b693cc40432115cbe3","permalink":"thwfhk.github.io/talk/example/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"thwfhk.github.io/talk/example/","section":"talk","summary":"An example talk using Wowchemy's Markdown slides feature.","tags":[],"title":"Example Talk","type":"talk"},{"authors":null,"categories":[],"content":" äººçš„æœ¬è´¨æ˜¯ä¸€åˆ‡ç¤¾ä¼šå…³ç³»çš„æ€»å’Œ\n è¿™æ˜¯ä¸€ç¯‡å…³äºCategory Theory in Contextçš„ç¬¬äºŒç« Universal Properties, Representability, and the Yoneda Lemmaçš„å­¦ä¹ ç¬”è®°ï¼Œè®°å½•äº†æ ¸å¿ƒå†…å®¹ä¸ä¸€äº›ä¸ªäººç†è§£ã€‚\nMotivation: æœ€åŸºæœ¬çš„æè¿°universal propertyçš„æ–¹å¼æ˜¯ï¼šæŸä¸ªobjectæ˜¯æŸä¸ªcategoryçš„initial/terminal objectã€‚è¿™ç§æ–¹å¼çš„é—®é¢˜åœ¨äºéœ€è¦æ„é€ å¤æ‚çš„categoryã€‚æˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ç§æ›´æ–¹ä¾¿çš„æè¿°universal propertyçš„æ–¹å¼ï¼šé€šè¿‡representable functoræ¥æè¿°ä»cæ˜ å°„å‡º/æ˜ å°„åˆ°cçš„æ‰€æœ‰æ˜ å°„çš„æ ·å­ã€‚\nRepresentable Functors ä»¥ä¸‹å‡å‡è®¾\\(C\\) is locally small.\n[Def] \\(C\\) is locally small, \\(c\\in C\\),\n \\(C(c,-):C\\to Set\\)æ˜¯ covariant functor represented by \\(c\\) \\(C(-,c):C^{op}\\to Set\\)æ˜¯ contravariant functor represented by \\(c\\)    å¯¹äº\\(f:x\\to y\\), \\(C(c,f) = f_* : C(c,x)\\to C(c,y)\\)æ˜¯post-compositionï¼Œ\\(C(c,f) g = f g\\) å°†fåœ¨gä¹‹åï¼ˆå·¦ï¼‰ä½œç”¨ä¸Š\n å¯¹äº\\(f:x\\to y\\) ,\\(C(f,c):C(y,c)\\to C(x,c)\\)æ˜¯pre-compositionï¼Œ\\(C(-,c) f\\ g = gf\\)å°†fåœ¨gä¹‹å‰ï¼ˆå³ï¼‰ä½œç”¨ä¸Š\n  [Def] two-sided represented functor \\(\\mathrm{C}(-,-): \\mathrm{C}^{\\mathrm{op}} \\times \\mathrm{C} \\rightarrow \\text { Set }\\)\n å¯¹äº\\(f:w\\to x, h:y\\to z\\)ï¼Œ\\(C(f,h):C(x,y)\\to C(w,z)\\)åˆ†åˆ«å°†få¤åˆåœ¨gå‰ï¼Œhå¤åˆåœ¨gåã€‚\\(g:x\\to y\\)ï¼Œ\\(C(f,h)g = hgf\\)  [Def] Representable functor: \\(C\\) is locally small, \\(c\\in C\\),\n A covariant functor \\(F:C\\to Set\\) is representable if \\(C(c,-)\\cong F\\) A contravariant functor \\(F:C^{op}\\to Set\\) is representable if \\(C(-,c)\\cong F\\) ç§°\\(F\\) is represented by \\(c\\), \\(c\\)ç§°ä¸ºthe representing object  Yoneda Lemma ä¸ºäº†ç”¨representable functoræè¿°universal propertyï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“æ„é€ ä¸€ä¸ª\\(C(c,-)\\cong F\\)éœ€è¦ä»€ä¹ˆï¼Ÿæˆ‘ä»¬å…ˆçœ‹æ›´ä¸€èˆ¬çš„æƒ…å†µï¼Œæ„é€ \\(\\alpha : C(c,-)\\Rightarrow F\\)éœ€è¦ä»€ä¹ˆã€‚Yoneda lemmaå‘Šè¯‰æˆ‘ä»¬ï¼Œåªè¦ç»™å‡ºä¸€ä¸ª\\(x\\in F\\ c\\)å°±å¯ä»¥æ„é€ å‡ºä¸€ä¸ª\\(\\alpha\\).\n[Thm] Yoneda lemma: \\(C\\) is locally small, å¯¹äº\\(c\\in C\\),\n \\(F:C\\to Set\\), æœ‰åŒå°„\\(\\mathrm{Hom}(C(c,-),F)\\cong F\\ c\\), ä¸”natural in \\(c\\) and \\(F\\). \\(F:C^{op}\\to Set\\), æœ‰åŒå°„\\(\\mathrm{Hom}(C(-,c),F)\\cong F\\ c\\), ä¸”natural in \\(c\\) and \\(F\\).  Remark:\n ç†è§£ï¼šè¿™ä¸ªåŒå°„è¯´æ˜natural transformation \\(\\alpha:C(c,-)\\Rightarrow F\\) ä¸ \\(x\\in F\\ c\\) ä¹‹é—´çš„ä¸€ä¸€å¯¹åº” ä»å·¦åˆ°å³ï¼Œ\\(\\alpha_c(1_c)\\)å°±æ˜¯\\(F\\ c\\)ä¸­çš„ä¸€ä¸ªå…ƒç´  ä»å³åˆ°å·¦ï¼Œç»™å‡º\\(x\\in F\\ c\\)ï¼Œå†åˆ©ç”¨\\(\\alpha\\)çš„naturalityå°±å¯ä»¥ç¡®å®šä¸€ä¸ªnatural transformation \\(\\alpha\\). å®é™…ä¸Šï¼Œç»™å‡ºçš„å°±æ˜¯\\(\\alpha_c(1_c)\\). åŒå°„å…·ä½“æ„é€ ï¼š ä»å·¦åˆ°å³ \\(\\Phi: \\operatorname{Hom}(\\mathrm{C}(c,-), F) \\rightarrow F c\\), \\(\\Phi(\\alpha):=\\alpha_{c}\\left(1_{c}\\right)\\) ä»å³åˆ°å·¦ \\(\\Psi: F c \\rightarrow \\operatorname{Hom}(\\mathrm{C}(c,-), F)\\), \\(\\Psi(x)\\)å°±æ˜¯æŸä¸ªnatural transformatiton \\(\\alpha\\). \\(\\Psi(x)\\)å®šä¹‰ä¸ºå¯¹äº\\(f:c\\to d\\), \\(\\Psi(x)_d(f) = F f(x)\\). æ„é€ çš„æ ¸å¿ƒæƒ³æ³•æ˜¯åœ¨å¦‚ä¸‹äº¤æ¢å›¾ä¸­\\(1_c\\)çš„æ²¿ç€ä¸¤æ¡è·¯å¾„è®¡ç®—ç»“æœç›¸ç­‰ï¼Œè¯æ˜åªè¦éªŒè¯\\(\\Psi(x)\\)çš„naturalityã€$\\(æ˜¯\\)$çš„é€†ä»¥åŠæ•´ä¸ªåŒå°„natural in c and F.    ä¸€ä¸ªå…³äºsizeçš„é—®é¢˜ï¼šç”±äº\\(C\\) is locally small, ç”±functor categoryéƒ¨åˆ†çš„ç»“è®ºä¸èƒ½ä¿è¯\\(Set^C\\) is locally small, ä½†æ˜¯ä»Yoneda lemmaå¯ä»¥å¾—çŸ¥\\(\\mathrm{Hom}(C(c,-),F)\\)ï¼ˆè¿™æ˜¯\\(Set^C\\)ä¸­ä¸¤ä¸ªobjectsä¹‹é—´çš„mophismsé›†åˆï¼‰ç¡®å®æ˜¯ä¸€ä¸ªset.  Yoneda lemmaçš„ç­‰ä»·è¡¨è¿°ï¼š\\(\\Phi : \\mathrm{Hom}(y(-),-)\\Rightarrow ev\\) is a natural isomorphism.\n å…¶ä¸­functor \\(y\\) å®šä¹‰å¦‚ä¸‹å›¾æ‰€ç¤º    å…·ä½“è§£é‡Šç•¥  Yoneda Embedding Yoneda lemmaçš„ä¸€ä¸ªé‡è¦åº”ç”¨æ˜¯Yoneda embeddingï¼Œè¿™å¯ä»¥å‘Šè¯‰æˆ‘ä»¬ç”¨universal propertyåˆ»ç”»çš„objectsä¹‹é—´åŒæ„ã€‚\n[Thm] Yoneda embedding: \\(y\\) is a full and faithful embedding.\nRemark:\n ç†è§£ï¼šä»¥covariant Yoneda embeddingä¸ºä¾‹ï¼Œè¿™è¯´æ˜\\(\\forall c,d\\in C\\), \\(C(c,d)\\)ä¸\\(\\mathrm{Hom}(C(-,c),C(-,d))\\)ä¹‹é—´æœ‰åŒå°„ï¼Œå¹¶ä¸”è¯¥åŒå°„ä¿æŒcompositionå’Œidentityï¼ˆè¿™æ˜¯\\(y\\)çš„functorialityè¦æ±‚ï¼Œæ— éœ€è¯æ˜ï¼‰. è¿™ä¸ªåŒå°„å°†\\(f\\)æ˜ å°„åˆ°\\(f_*\\). full and faithful embeddingè¯´æ˜\\(C\\) is isomorphic to a full subcategory of \\(Set^{C^{op}}\\) è¯æ˜ä¸­ï¼Œè¯æ˜æ˜¯æ»¡å°„ç”¨åˆ°äº†yoneda lemma  [Prop] Yoneda embeddingçš„æ¨è®º\n è‹¥\\(x\\cong y\\), åˆ™\\(C(x,-)\\cong C(y,-)\\)ä¸”\\(C(-,x)\\cong C(-,y)\\) è‹¥\\(C(x,-)\\cong C(y,-)\\)æˆ–\\(C(-,x)\\cong C(-,y)\\)ï¼Œåˆ™\\(x\\cong y\\)  Universal Property æœ‰äº†ä¹‹å‰çš„å‡†å¤‡ï¼Œå°±å¯ä»¥ç»™å‡ºuniversal propertyçš„æè¿°äº†ï¼\n[Def] Universal property of \\(c\\in C\\)å®šä¹‰ä¸ºï¼š\n a reprensentable functor \\(F\\) a universal element \\(x\\in F c\\)  s.t. å®ƒä»¬é€šè¿‡Yoneda lemmaç»™å‡ºäº†ä¸€ä¸ªnatural isomorphism \\(C(c,-)\\cong F\\) (F covariant)æˆ–è€… \\(C(-,c)\\cong F\\) (F contravariant).\nRemark:\n ç”±Yoneda lemmaï¼Œ\\(x\\in F c\\)å¯¹åº”äº†ä¸€ä¸ªnatural transformation \\(\\alpha\\), å¹¶ä¸”æˆ‘ä»¬å¸Œæœ›å®ƒæ˜¯natural isomorphism. è¿™ä¸ª\\(\\alpha : C(c,-)\\Rightarrow F\\)çš„å®šä¹‰å¦‚ä¸‹ï¼š \\(\\alpha_c(1_c) = x\\) \\(f:c\\to d,\\ \\alpha_d(f) = F f(x)\\) ç”±Yoneda embeddingçš„æ¨è®ºï¼Œ\\(c\\)åœ¨åŒæ„æ„ä¹‰ä¸‹å”¯ä¸€ ç›´è§‚ä¸Šï¼Œä¸€ä¸ªuniversal property of cåˆ»ç”»äº†cå‡º/å…¥æ˜ å°„çš„æ€§è´¨  è¿™ç§universal propertyçš„æè¿°ä¸ä¹‹å‰çš„æè¿°æœ‰ä»€ä¹ˆè”ç³»å‘¢ï¼Ÿä¸‹é¢æˆ‘ä»¬æƒ³è¯´æ˜ï¼šä¸€ä¸ªuniversal elementæ˜¯æŸä¸ªcategoryä¸­çš„initial/terminal object.\n[Def] Category of elements\n å¯¹äº\\(F:C\\to Set\\), Category of elements \\(\\int F\\) objectsï¼š\\((c,x)\\) where \\(c\\in C,\\ x\\in F\\ c\\) morphisms: a morphism \\((c,x)\\to (c\u0026#39;,x\u0026#39;)\\) is a \\(f:c\\to c\u0026#39;\\) s.t. \\(F f(x)=x\u0026#39;\\) å¯¹äº\\(F:C^{op }\\to Set\\), Category of elements \\(\\int F\\) objectsï¼š\\((c,x)\\) where \\(c\\in C,\\ x\\in F\\ c\\) morphisms: a morphism \\((c,x)\\to (c\u0026#39;,x\u0026#39;)\\) is a \\(f:c\\to c\u0026#39;\\) s.t. \\(F f(x\u0026#39;)=x\\)  Remarks:\n ç›´è§‚ç†è§£ï¼Œ\\(\\int F\\)æŠŠæ‰€æœ‰é›†åˆ\\(F\\ c\\)ä¸­çš„å…ƒç´ æ‹¿å‡ºæ¥ä½œä¸ºobjects  [Prop]\n \\(F:C\\to Set\\) is reprensentable iff \\(\\int F\\) has an initial element \\(F^{op}:C\\to Set\\) is reprensentable iff \\(\\int F\\) has an terminal element  Remark:\n è¿™ä¸ªæ¨è®ºè¯´æ˜ï¼Œinitial element \\((c,x)\\in \\int F\\) ä¸­çš„\\(x\\) å°±æ˜¯ universal property of \\(c\\)ä¸­çš„universal element \\(x\\)ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒé€šè¿‡Yoneda lemmaç»™å‡ºäº†ä¸€ä¸ªnatural isomorphism.\n a representation of \\(F\\) æ˜¯\\(c\\)å’Œè‡ªç„¶åŒæ„\\(C(c,-)\\cong F\\). æ³¨æ„åˆ°è¿™å’Œinitial object \\((c,x)\\in \\int F\\)ç­‰ä»·ï¼Œå› æ­¤æœ‰æ—¶å€™ä¹Ÿè¯´a representation of \\(F\\) is the initial object in \\(\\int F\\).\n  ä¾‹å­ 1. initial object è€ƒè™‘initial object \\(c\\in C\\)çš„universal propertyï¼Œæ˜¯constant functor \\(*:C\\to Set\\) (å°†ä»»æ„\\(d\\in C\\)æ˜ å°„åˆ°singleton set \\(*\\))å’Œuniversal element \\(x\\in *\\) (åªæœ‰å”¯ä¸€ä¸€ä¸ªå…ƒç´ )ä½¿å¾—\\(C(c,-)\\cong *\\).\n\\((c,x)\\in \\int *\\) æ˜¯initial objectå®é™…ä¸Šå°±æ˜¯è¯´\\(c\\in C\\)æ˜¯initial objectï¼ˆå› ä¸ºxä½ç½®ä¸Šåªæœ‰xè¿™ä¸€ä¸ªå…ƒç´ ï¼‰ã€‚\n2. å›¾æŸ“è‰² è¿™ä¸ªä¾‹å­æ¥è‡ªCategory in Context, æˆ‘è§‰å¾—è¿™ä¸ªä¾‹å­å¾ˆå½¢è±¡å¾ˆCSã€‚\nè€ƒè™‘functor \\(nColorï¼šGraph^{op}\\to Set\\) å°†å›¾gæ˜ å°„åˆ°gçš„æ‰€æœ‰næŸ“è‰²æ–¹æ¡ˆçš„é›†åˆã€‚\\(nColor\\)æ˜¯contravariantçš„å› ä¸ºæœ‰äº†å›¾åŒæ€\\(f:G\\to G\u0026#39;\\) ï¼Œåˆ©ç”¨å›¾åŒæ„ä¿æŒé¡¶ç‚¹ç›¸é‚»å…³ç³»ï¼Œå¯ä»¥ä»\\(G\u0026#39;\\)çš„æŸ“è‰²æ–¹æ¡ˆå¾—åˆ°\\(G\\)çš„æŸ“è‰²æ–¹æ¡ˆã€‚\næˆ‘ä»¬å®£ç§°å®Œå…¨å›¾\\(K_n\\) represents \\(nColor\\), ä¹Ÿå°±æ˜¯è¯´\\(Graph(-,K_n)\\cong nColor\\). ï¼ˆè¿™ä¸ªè‡ªç„¶åŒæ„éå¸¸ç›´è§‚ï¼Œå¯ä»¥æŠŠæ˜ å°„åˆ°é¡¶ç‚¹næƒ³è±¡æˆæŸ“ä¸Šé¢œè‰²nï¼‰ã€‚\næ­¤æ—¶ï¼Œuniversal property of \\(K_n\\)å°±æ˜¯ï¼š\n a representable functor \\(nColor\\) a universal element \\(x\\in nColor\\ K_n\\)  ä½¿å¾—\\(x\\)ç”±Yoneda lemmaå®šä¹‰çš„natural transformationæ˜¯ä¸ªnatural isomorphism.\nç”±äºè¯¥é—®é¢˜çš„ç‰¹æ®Šæ€§ï¼Œ\\(x\\)å¯ä»¥ä»»å–ã€‚\nè€ƒè™‘\\(\\int nColor\\), é‡Œé¢çš„objectsæ˜¯\u0026quot;ä¸€ä¸ªå›¾+è¯¥å›¾çš„ä¸€ç§æŸ“è‰²æ–¹æ¡ˆ=a n-colored graph\u0026quot;, morphismsæ˜¯ä¿æŒé¢œè‰²çš„å›¾åŒæ€ã€‚æ‰€ä»¥\\((c,x)\\)å°±æ˜¯terminal n-colored graph.\n","date":1601373090,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601373090,"objectID":"326bc4f9acf6653d445e2d26f8ad8d4e","permalink":"thwfhk.github.io/post/yoneda_lemma/","publishdate":"2020-09-29T17:51:30+08:00","relpermalink":"thwfhk.github.io/post/yoneda_lemma/","section":"post","summary":" äººçš„æœ¬è´¨æ˜¯ä¸€åˆ‡ç¤¾ä¼šå…³ç³»çš„æ€»å’Œ\n","tags":["Category Theory"],"title":"ä¸‡æœ‰æ€§è´¨å’Œç±³ç”°å¼•ç†","type":"post"},{"authors":null,"categories":[],"content":" æŸç§æ„ä¹‰ä¸Šï¼Œé«˜é˜¶æ„å‘³ç€ä¸€ç­‰å…¬æ°‘ï¼ˆ\n åœ¨é˜…è¯»PLç›¸å…³çš„è®ºæ–‡ä»¥åŠå‡½æ•°å¼è¯­è¨€çš„ç›¸å…³èµ„æ–™çš„æ—¶å€™ï¼Œç»å¸¸ä¼šçœ‹åˆ°\u0026quot;higher-order xxx\u0026ldquo;æˆ–è€…\u0026rdquo;higher-xxx yyy\u0026ldquo;è¿™ç§æ ¼å¼çš„è¯è¯­ï¼Œä»¿ä½›æ˜¯ä¸€åˆ‡ä¸œè¥¿å‰é¢éƒ½èƒ½åŠ ä¸ªhigher-orderã€‚æˆ‘æ—¶å¸¸åˆ†ä¸æ¸…ä»–ä»¬çš„å«ä¹‰ï¼Œäºæ˜¯æˆ‘æƒ³ä»è¯­è¨€çš„è§’åº¦æ€»ç»“ä¸€ä¸‹å„ç§higher/higher-orderå¼€å¤´çš„è¯è¯­ã€‚å¯ä»¥å‘ç°ä»–ä»¬ä¹‹é—´è¿˜æ˜¯å¾ˆç›¸ä¼¼çš„ã€‚\nHigher-order Functions higher-order function æŒ‡æ¥å—å‡½æ•°ä½œä¸ºå‚æ•°çš„å‡½æ•°ï¼ˆæœ‰æ—¶å€™è¿”å›å‡½æ•°çš„å‡½æ•°ä¹Ÿç®—ï¼‰ï¼Œæ¯”å¦‚map :: (a -\u0026gt; b) -\u0026gt; [a] -\u0026gt; [b]ã€‚\nå¦‚æœæˆ‘ä»¬æŠŠtypeå†™æˆä¸€æ£µè¯­æ³•æ ‘ï¼Œå¯ä»¥å¯¹äºhigher-order functionçš„typeï¼Œå®ƒä»æ ¹èµ°åˆ°æŸä¸ª$(a\\to b)$çš„è·¯å¾„ä¸Šè‡³å°‘æœ‰ä¸€æ¬¡æ˜¯èµ°äº†æŸä¸ª$\\to$èŠ‚ç‚¹çš„å·¦è¾¹ã€‚\nåœ¨æ”¯æŒhigher-order functionçš„è¯­è¨€ä¸­ï¼Œå‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘ï¼ˆfirst-class citizenï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´å‡½æ•°å¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’ã€‚ä¸¥æ ¼æ¥è¯´ä¸€ç­‰å…¬æ°‘è¿˜åº”è¯¥æ”¯æŒèµ‹å€¼ã€å­˜å‚¨ç­‰æ“ä½œï¼Œä½†æˆ‘è§‰å¾—å·²ç»æ”¯æŒä½œä¸ºå‚æ•°ä¼ é€’å’Œè¿”å›äº†ï¼Œå…¶ä»–çš„åº”è¯¥ä¹Ÿéƒ½æ”¯æŒï¼ˆçº¯ç²¹çš„å‡½æ•°å¼è¯­è¨€ä¸åœ¨æ„è¿™äº›ğŸ¶ï¼‰ã€‚\nå¦‚æœå‡ºç°higher-order languageè¿™ä¸ªè¯ï¼Œä¸€èˆ¬æŒ‡æ”¯æŒhigher-order functionçš„è¯­è¨€ã€‚\nå¯¹åº”çš„lambda calculusçš„ä¾‹å­ï¼šsimply typed lambda calculus $\\lambda_\\to$.\nHigher-order Type (Operators) é¦–å…ˆç®€å•ä»‹ç»ä¸€ä¸‹å…³äºtype operatorå’Œkindçš„å‰ç½®çŸ¥è¯†ï¼š\næˆ‘ä»¬æƒ³è¦è®¨è®ºtype-level functions (or type operators, type constructors), æ¯”å¦‚Ref T , Pair S Tç­‰ç­‰ã€‚å› æ­¤åœ¨typeå±‚é¢å¼•å…¥äº†abstraction $\\lambda X::K.T$ å’Œapplication $T\\ T$ã€‚è¿™æ ·å°±æœ‰äº†type operatorsã€‚\nä¸ºäº†ä»arityä¸ŠåŒºåˆ†type (operators)ï¼Œæˆ‘ä»¬å¼•å…¥kinds (the types of types):\n a single atomic kind $*$ (pronounced \u0026ldquo;type\u0026rdquo;) a single constructor $\\Rightarrow$  ä¸€äº›ä¾‹å­ï¼š\n $*$ : the kind of proper types (or ground types, the sorts of type expressions that are actually used to classify terms), like $Bool,\\ Nat\\to Nat,\\ \\forall X.X\\to X$ $*\\Rightarrow $ : the kind of type operators (functions from proper types to proper types), like $\\lambda X.T$ (abbreviation for $\\lambda X::.T$) $* \\Rightarrow * \\Rightarrow *$ : the kind of functions from proper types to type operators $(* \\Rightarrow *) \\Rightarrow *$ : the kind of functions from type operators to proper types.  æœ‰$*\\Rightarrow \\cdots \\Rightarrow *$ è¿™ç§kindçš„typeç§°ä¸ºtype operatoræˆ–è€…first-order type operatorï¼›\nè€Œå¦‚æœæœ‰$(*\\Rightarrow *)$å‡ºç°åœ¨æŸä¸ª$\\Rightarrow$çš„å·¦å­æ ‘ï¼Œè¿™ç§type operatorç§°ä¸ºhigher-order type operators or higher-kinded type operatorsã€‚è¿™ä¸ªå®šä¹‰å’Œhigher-order functionæ˜¯å®Œå…¨ä¸€è‡´çš„ï¼Œåˆ«å¿˜äº†type operatoræ˜¯typeä¹‹é—´çš„functionã€‚\nhigher-order type operatorå¾ˆå°‘å‡ºç°ã€‚\nå¯¹åº”çš„lambda calculusçš„ä¾‹å­ï¼š$\\lambda_\\omega$\nHigher-rank Polymorphism Polymorphismæœ‰å¾ˆå¤šç§ï¼Œhigher-rank polymorphismæ˜¯å¯¹äºparametric polymorphismæ¥è¯´çš„ã€‚\nParametric polymorphismå…è®¸åœ¨typeä¸­å‡ºç°type variableå’Œquantifier ï¼ˆå¦‚$\\lambda X.t :: \\forall X.T$ï¼‰ï¼Œå¹¶åœ¨evaluationæ—¶ç”¨ä¸åŒçš„typeå®ä¾‹åŒ–type variableã€‚ä»–ä¸ad-hoc polymorphismçš„å¾ˆå¤§ä¸€ä¸ªä¸åŒåœ¨äºï¼šThe polymorphic functions act on different types uniformly. è¿™ä¹Ÿæ˜¯parametricity(see theorem for free)çš„æ¥æºã€‚\nä¸€äº›ä¾‹å­ï¼šSystem $F$ï¼ŒFPä¸­å¤§éƒ¨åˆ†è¯­è¨€ï¼Œé¢å‘å¯¹è±¡ä¸­çš„genericsï¼ŒC++ä¸­çš„templateã€‚\nå‡ ç§åˆ†ç±»ï¼š\n let-polymorphsim(prenex polymorphism): åªå…è®¸polymorphismå‡ºç°åœ¨top-level let-bindingsï¼Œä¹Ÿå°±æ˜¯è¯´quantifieråªèƒ½å‡ºç°åœ¨æœ€å¤–å±‚ï¼Œå› æ­¤type variablesåªèƒ½instantiateæˆquntifier-free typeã€‚åˆç§°ä¸ºrank-1 polymorphism. rank-2 polymorphism: æŠŠtypeå†™æˆè¯­æ³•æ ‘æ ‘ï¼Œä»æ ¹åˆ°ä»»ä¸€ä¸ª$\\forall$ quantifierçš„è·¯å¾„ä¸èµ°ä¸¤æ¬¡æˆ–ä»¥ä¸Š$\\to$èŠ‚ç‚¹çš„å·¦è¾¹ã€‚æ¯”å¦‚$(\\forall X.X\\to X)\\to Nat$å°±æ˜¯èµ°äº†ä¸€æ¬¡ã€‚ rank-k polymorphism (å¦‚ä¸Šç±»æ¨) rank-n polymorphismåˆç§°ä¸ºhigher-rank polymorphism or impredicative (first-class) polymorphismï¼Œå…è®¸ä»»æ„å¤šæ¬¡ã€‚æ³¨æ„åˆ°ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥å°†polymorphic functionä»»æ„çš„å½“ä½œå‚æ•°è¿›è¡Œä¼ é€’ï¼Œå› æ­¤polymorphic functionå˜æˆäº†ä¸€ç­‰å…¬æ°‘ã€‚  Haskellæ”¯æŒrank-n polymorphismï¼Œ{-# LANGUAGE Rank2Types #-} {-# LANGUAGE Rank2Types #-}å®é™…ä¸Šå°±æ˜¯ç”¨æ¥å¼€å¯rank-n polymorphism. è¿™æ ·å°±å¯ä»¥å†™å‡ºf :: (forall n. n-\u0026gt;n) -\u0026gt; (Int, Double)è¿™ç§å‡½æ•°ã€‚æ³¨æ„å®ƒä¸f :: forall n . (n-\u0026gt;n) -\u0026gt; (Int, Double)çš„åŒºåˆ«ï¼šå‰è€…æ¥å—ä¸€ä¸ªèƒ½ä½œç”¨äºä»»æ„ç±»å‹nå¹¶è¿”å›ç±»å‹nçš„å‡½æ•°ï¼Œåè€…æ¥å—çš„å‡½æ•°ä¸­næ˜¯ä»»æ„ä¸€ä¸ªå…·ä½“çš„ç±»å‹äº†ã€‚\nå¯¹åº”çš„lambda calculusçš„ä¾‹å­ï¼špolymorphic lambda calculus $F$ (System F)\n å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒHaskellçš„functionå¹¶ä¸æ”¯æŒexplicit type-level abstractionï¼ˆè€ŒSystem Fä¸­æ”¯æŒï¼‰ï¼Œå› ä¸ºè¿™ä¼šä½¿type inferenceå˜æˆundecidableã€‚Haskellçš„ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ¨æ–­type variableåº”è¯¥å®ä¾‹åŒ–æˆå“ªä¸ªç±»å‹ã€‚\nåœ¨åŠ å…¥pragma{-# language TypeApplications #-}åå¯ä»¥å†™å‡ºidInt = id @Int\n Higher-order Polymorphism higher-order polymorphism or higher-kinded polymorphismä¹Ÿæ˜¯å¯¹äºparametric polymorphismæ¥è¯´çš„ï¼Œå°±æ˜¯å°†å‰ä¸¤èŠ‚æåˆ°çš„higher-kinded typeä¸higher-rank polymorphismç»“åˆåˆ°ä¸€èµ·ï¼Œå…è®¸parametric polymorphismçš„type variableéå†type operatorã€‚\nä¾‹å¦‚ï¼š\ntype Ground = Int type FirstOrder a = Maybe a -- a is ground type SecondOrder c = c Int -- c is a first-order constructor type ThirdOrder c = c Maybe -- c is second-order  Haskellä¸­fmap :: forall f. Functor f =\u0026gt; (a -\u0026gt; b) -\u0026gt; f a -\u0026gt; f bï¼Œf :: *-\u0026gt;*æ˜¯ä¸€ä¸ªtype operatorï¼Œæ‰€ä»¥è¿™æ˜¯ä¸ªhigher-order polymorphismã€‚è¿™ä¸ªä¾‹å­ä¸­åªç”¨åˆ°äº†rank-1 polymorphismï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å†™å‡ºåŒæ—¶ç”¨åˆ°rank-2 polymorphismå’Œhigher-order polymorphismçš„ä¾‹å­ï¼šret :: Monad m' =\u0026gt; (forall m. Monad m =\u0026gt; a -\u0026gt; m a) -\u0026gt; a -\u0026gt; m' aã€‚\nå¯¹åº”çš„lambda calculusçš„ä¾‹å­ï¼šHigher-order polymorphic lambda-calculus $F_\\omega$\nåè®° æœ¬æ¥æƒ³å†™parametricityç»“æœå‘ç°å‘è¶Šæ¥è¶Šå¤§ï¼Œäºæ˜¯æ°´ç‚¹ç®€å•çš„ä¸œè¥¿ã€‚\nå¸Œæœ›æœ‰æ—¶é—´å»è®¤çœŸå­¦ä¸€ä¸‹ä»–ä»¬ä¸logicçš„è”ç³»ã€‚\n","date":1598348622,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1598348622,"objectID":"e5a5ea55cdc62146945075543ea85f9a","permalink":"thwfhk.github.io/post/higher_order_xxx/","publishdate":"2020-08-25T17:43:42+08:00","relpermalink":"thwfhk.github.io/post/higher_order_xxx/","section":"post","summary":" æŸç§æ„ä¹‰ä¸Šï¼Œé«˜é˜¶æ„å‘³ç€ä¸€ç­‰å…¬æ°‘ï¼ˆ\n","tags":["Haskell","Programming Language Theory"],"title":"åŒºåˆ†ä¸€äº›Higher-orderå¼€å¤´çš„è¯","type":"post"},{"authors":null,"categories":[],"content":" All told, monad is just a monoid in the category of endofunctors.\n è¿é¸½ä¸¤ä¸ªæœˆåç»ˆäºåœ¨å…«æœˆä»½çš„æœ«å°¾å†æ¬¡æ›´æ–°ï¼ˆå¡«å‘ï¼‰ã€‚\nå¯’å‡çš„æ—¶å€™å†™è¿‡ä¸€ä¸ªå…³äºâ€œHaskellä¸­monadä¸èŒƒç•´è®ºæœ‰ä»€ä¹ˆè”ç³»â€çš„æ–‡ç« ï¼Œå½“æ—¶å†™å¾—å¾ˆnaiveï¼Œç°åœ¨äº†è§£çš„æ›´å¤šäº†ä¸€ç‚¹ï¼Œäºæ˜¯å†³å®šé‡å†™ä¸€ä¸‹ã€‚ä¸»è¦å‚è€ƒèµ„æ–™æ˜¯Category Theory for Programmerså’ŒCategory Theory in Context.\nMonads in Haskell é¦–å…ˆå›é¡¾ä¸€ä¸‹Haskellä¸­çš„monadã€‚\nHaskellä¸­çš„Monad mæ˜¯ä¸€ä¸ªtypeclassï¼Œä»–æœ¬èº«æ˜¯ä¸€ä¸ªå‡½å­ï¼ˆå› æ­¤m :: * -\u0026gt; *ï¼‰ï¼Œå¸¦æœ‰ä¸€äº›æ»¡è¶³ç‰¹æ®Šæ€§è´¨çš„è¿ç®—ã€‚\nåœ¨Haskellä¸­å¯¹monadæœ‰ä¸‰ç§ç­‰ä»·çš„å®šä¹‰ï¼Œåˆ†åˆ«ä½¿ç”¨fish, bind, joiné…åˆreturn.\nfishğŸŸ å¯¹äºcategory $C$å’Œendofunctor $m$ï¼Œæˆ‘ä»¬å¯ä»¥å°†aåˆ°bçš„morphismsæ¢æˆ$a\\to m\\ b$çš„å‡½æ•°ï¼ˆè¿™æ ·çš„å‡½æ•°ç§°ä¸ºKleisli arrowsï¼‰ï¼Œ è‹¥å¯ä»¥å®šä¹‰æ»¡è¶³æ¡ä»¶çš„compositionå’Œidentity morphismï¼Œå¾—åˆ°çš„æ–°èŒƒç•´å°±æ˜¯$C$å¯¹åº”çš„Kleisli category $K$ ï¼Œæ­¤æ—¶ç§°$m$æ˜¯ä¸€ä¸ªmonadã€‚\nåœ¨haskellä¸­æ˜¯è¿™æ ·å®šä¹‰çš„ï¼š\nclass Monad m where (\u0026gt;=\u0026gt;) :: (a -\u0026gt; m b) -\u0026gt; (b -\u0026gt; m c) -\u0026gt; (a -\u0026gt; m c) return :: a -\u0026gt; m a  æ³¨æ„åˆ°\u0026gt;=\u0026gt;(fish operator)å°±æ˜¯compositionï¼Œreturnæ˜¯identity morphismï¼ˆçš„polymorphicç‰ˆæœ¬ï¼‰ã€‚\næ­¤æ—¶monad lawsååº”çš„å°±æ˜¯Kleisli categoryå¯¹compositionçš„è¦æ±‚ï¼š\nreturn \u0026gt;=\u0026gt; f = f -- left unit f \u0026gt;=\u0026gt; return = f -- right unit (f \u0026gt;=\u0026gt; g) \u0026gt;=\u0026gt; h = f \u0026gt;=\u0026gt; (g \u0026gt;=\u0026gt; h) -- associativity  bind è§‚å¯Ÿåˆ°\u0026gt;=\u0026gt;ç¬¬ä¸€æ­¥å¿…å®šæ˜¯å°†a -\u0026gt; m bä½œç”¨äºaï¼Œå› æ­¤å¯ä»¥å°†ç¬¬ä¸€ä¸ªa -\u0026gt; m bæ¢æˆm bï¼Œç®€åŒ–å¾—åˆ°\u0026gt;\u0026gt;=ï¼ˆbindï¼‰ï¼Œè¿™æ˜¯haskellä¸­æ ‡å‡†çš„monadçš„å®šä¹‰ï¼š\nclass Monad m where (\u0026gt;\u0026gt;=) :: m a -\u0026gt; (a -\u0026gt; m b) -\u0026gt; m b return :: a -\u0026gt; m a (\u0026gt;\u0026gt;) :: m a -\u0026gt; m b -\u0026gt; m b m \u0026gt;\u0026gt; k = m \u0026gt;\u0026gt;= (\\_ -\u0026gt; k)  ç›´è§‚ä¸Šï¼Œbindå°†ä¸€ä¸ªæœ‰contextçš„valueç»™äº†ä¸€ä¸ªa -\u0026gt; m bç±»å‹çš„å‡½æ•°ï¼Œä»–æä¾›äº†ä¸€ç§â€œä»contexté‡Œæ‹¿å‡ºå€¼â€çš„æ–¹æ³•ã€‚\nä¸fishäº’ç›¸è¡¨ç¤ºï¼š\nf \u0026gt;=\u0026gt; g = \\x -\u0026gt; f x \u0026gt;\u0026gt;= g x \u0026gt;\u0026gt;= f = ((\\_ -\u0026gt; x) \u0026gt;=\u0026gt; f) () -- one possible version  å¯ä»¥å°†fishè¡¨ç¤ºçš„monad lawsè½¬æ¢ä¸ºç­‰ä»·çš„bindè¡¨ç¤ºçš„monad lawsï¼š\nreturn x \u0026gt;\u0026gt;= f = f x mx \u0026gt;\u0026gt;= return = mx (mx \u0026gt;\u0026gt;= f) \u0026gt;\u0026gt;= g = mx \u0026gt;\u0026gt;= (\\x -\u0026gt; f x \u0026gt;\u0026gt;= g) -- æˆ–è€…å†™æˆ(m \u0026gt;\u0026gt;= \\x -\u0026gt; f x) \u0026gt;\u0026gt;= g = m \u0026gt;\u0026gt;= (\\x -\u0026gt; f x \u0026gt;\u0026gt;= g)æ›´æ¸…æ¥šä¸€ç‚¹  join è§‚å¯Ÿåˆ°æˆ‘ä»¬å¯ä»¥å€ŸåŠ©fmapæ¥åº”ç”¨å‡½æ•°fï¼Œå› æ­¤åªè¦ä¸€ä¸ªjoin :: m(m a) -\u0026gt; m aå°±å¯ä»¥å®ç°bindçš„åŠŸèƒ½ï¼š\nclass Functor m =\u0026gt; Monad m where join :: m (m a) -\u0026gt; m a return :: a -\u0026gt; m a  ä¸bindäº’ç›¸è¡¨ç¤ºï¼š\nx \u0026gt;\u0026gt;= f = join (fmap f x) join x = x \u0026gt;\u0026gt;= id  joinè¡¨ç¤ºçš„monad lawsåœ¨ä¸‹æ–‡ä¸­ä¼šä»Category Theoryä¸­å¯¹$\\eta,\\mu$çš„è¦æ±‚ä¸­æ¨å‡ºï¼Œå¯ä»¥éªŒè¯è¿™ä¸¤æ¡å’Œä¹‹å‰çš„monad lawsç­‰ä»·ã€‚\ndo notation doå®é™…ä¸Šæ˜¯ä¸€ä¸ªsyntactic sugar:\ndo {x1 \u0026lt;- m1; x2 \u0026lt;- m2; f x1 x2} = m1 \u0026gt;\u0026gt;= \\x1 -\u0026gt; m2 \u0026gt;\u0026gt;= \\x2 -\u0026gt; f x1 x2  å¯ä»¥ç±»ä¼¼å‘½ä»¤å¼æ¥å†™å‡½æ•°å¼ã€‚\nä¸Šè¿°monad lawsç”¨do notationè¡¨ç¤ºçš„è¯å°±æ˜¯ï¼š\ndo {x' \u0026lt;- return x; return x'} = do {f x} do {x \u0026lt;- mx; return x} = do {mx} do {y \u0026lt;- do {x \u0026lt;- mx; f x}; g y} = do {x \u0026lt;- mx; y \u0026lt;- f x; g y}  Monads in Category Theory åœ¨Category Theoryä¸­ï¼Œmonadçš„å½¢å¼åŒ–å®šä¹‰å¦‚ä¸‹ï¼š\n[Def] A monad on a category $C$ consists of:\n an endofunctor $T:C\\to C$ a multiplication natural transformation $\\mu : T^2 \\Rightarrow T$ a unit natural transformation $\\eta : 1_C\\Rightarrow T$  Coherence conditions: the following diagrams commute\næˆ‘ä»¬å‡è®¾Haskellæœ‰ä¸€ä¸ªHaskèŒƒç•´ï¼ˆobjectsæ˜¯typeï¼Œmorphimsæ˜¯functionsï¼‰çš„è¯ï¼ŒHaskellä¸­çš„monadå°±æ˜¯HaskèŒƒç•´ä¸Šçš„monadï¼Œå…¶ä¸­returnå°±æ˜¯$\\eta$ï¼Œjoinå°±æ˜¯$\\mu$ï¼ˆå‡†ç¡®çš„è¯´æ˜¯components $\\eta_a,\\mu_a$çš„polymorphicç‰ˆæœ¬ï¼‰ï¼Œä»–ä»¬éœ€è¦æ»¡è¶³çš„monad lawså°±æ˜¯$\\eta,\\mu$çš„ä¸¤ä¸ªå›¾äº¤æ¢ï¼š\n $\\mu \\circ T \\mu = \\mu \\circ \\mu T$ : join . fmap (join) = join . join $\\mu \\circ T \\eta = \\mu \\circ \\eta T = 1_T$ : join . fmap (unit) = join . unit = id  å½“ç„¶$\\eta,\\mu$è¿˜è¦æ»¡è¶³ä½œä¸ºè‡ªç„¶å˜æ¢çš„coherence conditionsï¼Œä¸è¿‡è¿™ä¸¤ä¸ªæ¡ä»¶ç”±äºTheorems for Freeè€Œè‡ªåŠ¨æ»¡è¶³ï¼š\n return . f = fmap f . return join . fmap (fmap f) = fmap f . join  æ‰€ä»¥Haskellä¸­çš„monadä¸Category Theoryä¸­çš„monadæ˜¯ä¸€è‡´çš„ï¼Œæ¥ä¸‹æ¥åªè¦è§£é‡ŠCategory Theoryä¸­monadä¸ºä»€ä¹ˆæ˜¯a monoid in the endofunctor category. æˆ‘ä»¬éœ€è¦å…ˆè¡¥å……ä¸€äº›Category Theoryä¸­çš„æ¦‚å¿µã€‚\nMonoid and Monoidal Category Monoid ç»å…¸çš„monoidï¼ˆå¹ºåŠç¾¤ï¼‰æ˜¯åœ¨é›†åˆä¸Šå®šä¹‰çš„ï¼Œäººå¦‚å…¶åï¼Œæœ‰ä¹˜æ³•è¿ç®—å’Œå•ä½å…ƒã€‚\n[Def] A monoid is an object $M\\in Set$ together with two morphisms $\\mu : M\\times M\\to M$ and $\\eta :1\\to M$.\nCoherence conditions: the following diagrams commute\nè¿™ä¸ªå®šä¹‰å’ŒæŠ½è±¡ä»£æ•°ä¸­æ˜¯ç­‰ä»·çš„ï¼Œ$\\mu$ç»™å‡ºäº†ä¸€ä¸ªäºŒå…ƒè¿ç®—å¹¶æ»¡è¶³ç»“åˆå¾‹ï¼ˆå›¾1ï¼‰ï¼Œ$\\eta$ç»™å‡ºäº†ä¸€ä¸ªå•ä½å…ƒï¼ˆå›¾2ï¼‰ã€‚\næˆ‘ä»¬å¯ä»¥æŠŠmonoidä»Setä¸Šæ¨å¹¿åˆ°å…¶ä»–categoryä¸Šï¼Œèƒ½åœ¨ä¸Šé¢å®šä¹‰monoidçš„categoryéœ€è¦æ»¡è¶³ä¸€å®šæ¡ä»¶ï¼Œç§°ä¸ºmonoidal categoryã€‚\nMonoidal Category ç›´è§‚ä¸Šï¼Œè¦æƒ³åœ¨ä¸€ä¸ªcategoryä¸Šå®šä¹‰monoidï¼Œè¿™ä¸ªcategoryéœ€è¦æœ‰ä¸€ä¸ªobjectsä¹‹é—´çš„productï¼Œè¿˜è¦èƒ½ä»æ¯ä¸ªobjectsä¸­æ‹¿å‡ºä¸€ä¸ªunit elementã€‚æˆ‘ä»¬ä¸èƒ½ä»categoryçš„objectsé‡Œæ‹¿ä¸œè¥¿ï¼Œä½†å¯ä»¥åˆ©ç”¨terminal objectåˆ°å…¶ä»–objectsçš„æ˜ å°„æ¥å–å•ä½å…ƒï¼Œæ‰€ä»¥è¿™ä¸ªcategoryè¦æœ‰ä¸€ä¸ªç±»ä¼¼terminal objectçš„ä¸œè¥¿ã€‚ã€‚\nmonoidal categoryçš„å½¢å¼åŒ–å®šä¹‰å¦‚ä¸‹ï¼š\n[Def] A symetric monoidal category$(V,\\otimes,*)$ is a category $V$ together with:\n a bifunctor $-\\otimes-:V\\times V\\to V$ called monoidal product (or tensor product) a unit object $*$.  Coherence conditions: three coherence natural isomorphisms\nRemarks:\n  æ³¨æ„$\\alpha$è¿™äº›natural isomorphismsæ˜¯multifunctorsä¹‹é—´çš„ï¼Œä»–çš„componentsæ˜¯$\\alpha_{u,v,w}$\n  ä¸‰ä¸ªcoherence conditionsåˆ†åˆ«æ˜¯symetric, associativity, unit conditions on the monoidal product. åªæ»¡è¶³åä¸¤ä¸ªçš„è¯ç§°ä¸ºmonoidal category\n  å¦‚æœè¿™äº›natural isomorphismså¯ä»¥å–identity natural isomorphismsçš„è¯ï¼Œç§°ä¸ºstrict monoidal category.\n  Examples:\n All categories with ï¬nite products such as $(Set,\\times, * ), (Top,\\times,*),(Cat,\\times,1)$, where the monoidal unit in each case is the terminal object. å¯¹å¶åœ°ï¼Œfinite coproductå’Œinitial objectä¹Ÿæ„æˆsymmetric monoidal categoryï¼Œå¦‚$(Set,+,{})$. HaskèŒƒç•´å¯ä»¥è¿‘ä¼¼çœ‹æˆSetï¼Œå› æ­¤productï¼ˆcoproductï¼‰åœ¨åŒæ„æ„ä¹‰ä¸‹æ»¡è¶³æ¡ä»¶ï¼Œterminal objectæ˜¯()ï¼ˆEmptyï¼‰ï¼Œå› æ­¤Haskæ˜¯monoidal categoryã€‚ A commutative monoidçœ‹ä½œdiscrete category(å³åªæœ‰identity morphisms)çš„è¯ä¹Ÿå®šä¹‰äº†ä¸€ä¸ªsymetric monoidal categoryï¼Œæ­¤æ—¶natural isomorphismså°±æ˜¯identitiesã€‚å¦ä¸€æ–¹é¢ï¼Œç»å…¸çš„monoidå°±æ˜¯Setä¸Šçš„monoidã€‚  Monoid in a Monoidal Category åœ¨monoidal category$(V,\\otimes,*)$ä¸Šå®šä¹‰monoidï¼Œæˆ‘ä»¬éœ€è¦å–ä¸€ä¸ªobject $M\\in V$ä»¥åŠä¸¤ä¸ªmorphisms $\\mu : M\\otimes M\\to M$, $\\eta : * \\to M$. Coherence conditionså’Œç»å…¸monoidç›¸åŒã€‚\nMonad as a Monoid ç»ˆäºæ¥åˆ°äº†æ­£é¢˜ã€‚å®é™…ä¸Šç»è¿‡å‰é¢çš„é“ºå«ï¼Œå‰©ä¸‹çš„å†…å®¹å°±å¾ˆç®€å•äº†ï¼š\næˆ‘ä»¬è€ƒè™‘functor category $C^C$ï¼Œå®ƒçš„objectsæ˜¯functorsï¼Œmorphismsæ˜¯natural transformationsã€‚å®ƒæ˜¯ä¸€ä¸ªstrict monoidal categoryï¼Œmonoidal productæ˜¯composition between functorsï¼Œunit objectæ˜¯identity endofunctorã€‚æ³¨æ„æ­¤æ—¶composition(ä¸€èˆ¬çœç•¥è¿ç®—ç¬¦) $-\\circ -:C^C \\times C^C \\to C^C$æ˜¯ä¸€ä¸ªbifunctorï¼Œå®ƒæ˜¯å¯ä»¥ä½œç”¨äºnatural transformationçš„ï¼Œä½œç”¨æ•ˆæœå°±æ˜¯natural transformationçš„horizontal compositionã€‚\né‚£ä¹ˆ$C^C$ä¸Šçš„monoidæ˜¯ä»€ä¹ˆæ ·çš„å‘¢ï¼Ÿå–object $T\\in C^C$ï¼Œmorphisms $\\mu,\\eta\\in C^C$æ»¡è¶³æ¡ä»¶ã€‚ $T$å°±æ˜¯ä¸€ä¸ªmonadï¼æ‰€ä»¥A monad on $C$ is a monoid in the monoidal category $C^C$ of endofunctors on $C$. Bingo!\nåè®° å…¶å®è¿™ç¯‡æ–‡ç« ä¸€ç‚¹ä¹Ÿä¸å‹å¥½ï¼Œåªèƒ½ä½œä¸ºç»™è‡ªå·±çœ‹çš„å¤ä¹ ç¬”è®°ã€‚\nmonadç›¸å…³è¿˜æœ‰å¥½å¤šæœ‰è¶£çš„å†…å®¹ï¼Œæ¯”å¦‚comonadã€adjunctionsç­‰ç­‰ï¼Œæœ‰æ—¶é—´ä¸€å®šå†™ã€‚\nå¸Œæœ›ä»¥åå¤šæ›´æ–°ä¸€ç‚¹æœ‰è¶£çš„ä¸œè¥¿ï¼ˆå–‚è‡³å°‘åšåˆ°æœˆæ›´å•Š\n","date":1598106327,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1598106327,"objectID":"940448171a902c17fdfb515758a4226a","permalink":"thwfhk.github.io/post/monad_is_a_monoid/","publishdate":"2020-08-22T22:25:27+08:00","relpermalink":"thwfhk.github.io/post/monad_is_a_monoid/","section":"post","summary":" All told, monad is just a monoid in the category of endofunctors.\n","tags":["Haskell","Category Theory"],"title":"Monadæ˜¯è‡ªå‡½å­èŒƒç•´ä¸Šçš„å¹ºåŠç¾¤","type":"post"},{"authors":null,"categories":["ç§‘æ™®å‘"],"content":" çˆ±æƒ…å…¶å®å°±æ˜¯é˜¿å¦®ç›/é˜¿å°¼å§†æ–¯åœ¨å¯¹æ–¹èº«ä¸Šçš„æŠ•å°„ã€‚\n è¿™æ˜¯ä¸€ç¯‡ç§‘æ™®å°çŸ­æ–‡ï¼Œå°½é‡ä½¿ç”¨äº†é€šä¿—æ˜“æ‡‚çš„è¯­è¨€æ¥æè¿°ï¼Œå¸Œæœ›èƒ½ç»™è¯»è€…å¸¦æ¥ä¸€ç‚¹ä¹è¶£ï¼\n ä¸‹é¢å¼€å§‹æ­£æ–‡ï¼š\nç”Ÿæ´»ä¸­æœ‰ä¸€ç§å¸¸è§çš„æƒ…æ™¯ï¼šâ€œAliceå¾ˆå–œæ¬¢Bobï¼Œæƒ³è¦å‘Bobè¡¨ç™½ï¼Œä½†æ˜¯åˆå®³æ€•å¯¹æ–¹ä¸å–œæ¬¢è‡ªå·±è€Œå¼•èµ·å°´å°¬ã€‚â€\nå¾ˆå¤šäººéƒ½ä¼šé™·å…¥è¿™ç§ä¸¤éš¾ï¼ˆdilemmaï¼‰ä¸­ï¼Œé‚£ä¹ˆæœ‰ä»€ä¹ˆåŠæ³•å¯ä»¥åœ¨ä¸æš´éœ²è‡ªå·±æ˜¯å¦å–œæ¬¢å¯¹æ–¹çš„å‰æä¸‹å¾—çŸ¥å¯¹æ–¹æ˜¯å¦å–œæ¬¢è‡ªå·±å‘¢ï¼Ÿ\nä¸€ä¸ªç®€å•çš„åšæ³•æ˜¯ï¼ŒAliceå’ŒBobåˆ†åˆ«å‘Šè¯‰Carolè‡ªå·±æ˜¯å¦å–œæ¬¢å¯¹æ–¹ï¼Œç„¶åCarolåŒæ—¶å‘Šè¯‰Aliceå’ŒBobä½ ä»¬æ˜¯å¦ç›¸äº’å–œæ¬¢å¯¹æ–¹ã€‚ä½†æ˜¯è¿™ç§æ–¹æ³•æœ‰ä¸€ä¸ªæ˜æ˜¾çš„é—®é¢˜ï¼šä½ å¯èƒ½å¹¶ä¸æƒ³è®©CarolçŸ¥é“è‡ªå·±çš„å¿ƒæ„ã€‚\né‚£æœ‰æ²¡æœ‰æ›´å®‰å…¨çš„æ–¹æ³•å‘¢ï¼Ÿ\nå½“ç„¶æ˜¯æœ‰çš„ã€‚äº‹å®ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥åšåˆ°â€œAliceå’ŒBobå¯ä»¥å¾—çŸ¥ä¸¤äººæ˜¯å¦äº’ç›¸å–œæ¬¢å¯¹æ–¹ï¼Œå¹¶ä¸”è‡ªå·±æ˜¯å¦å–œæ¬¢å¯¹æ–¹è¿™ä¸ªä¿¡æ¯ä¸ä¼šè¢«æ³„éœ²ç»™ä»»ä½•ä¸€ä¸ªäººâ€ï¼ˆå½“ç„¶äº†ï¼Œâ€œæœ€åç»“æœæ˜¯ç›¸äº’å–œæ¬¢â€è¿™ç§æ³„éœ²ä¸ç®—ï¼‰ã€‚å¹¶ä¸”ï¼Œè¿™ä¸€è¿‡ç¨‹åªéœ€è¦äº¤è°ˆå’Œ2ä»¥å†…çš„åŠ æ³•ä¹˜æ³•å°±å¯ä»¥å®Œæˆï¼Œæ— éœ€å€ŸåŠ©è®¡ç®—æœºç­‰è®¾å¤‡ã€‚\nä¸€ç§å®‰å…¨çš„æ–¹æ³• ä¸ºäº†è¡¨è¾¾æ–¹ä¾¿ï¼Œä¸‹é¢æ‰€æœ‰çš„æ•°éƒ½è¦ä¹ˆæ˜¯0è¦ä¹ˆæ˜¯1ï¼Œå¹¶ä¸”å®šä¹‰è¿ç®—\\(x\\land y = x\\times y,\\ x\\oplus y = (x+y) \\bmod 2\\)ï¼ˆ\\(\\bmod 2\\)è¡¨ç¤ºé™¤2å–ä½™æ•°ï¼‰ï¼Œå®é™…ä¸Šå°±æ˜¯äºŒè¿›åˆ¶çš„andè¿ç®—å’Œxorè¿ç®—ã€‚\nAliceæ‰‹é‡Œæœ‰ä¸€ä¸ªæ•°\\(x\\)ï¼Œå¦‚æœAliceå–œæ¬¢Bobï¼Œé‚£ä¹ˆ\\(x=1\\)ï¼Œå¦åˆ™\\(x=0\\)ï¼›åŒæ ·çš„ï¼ŒBobæ‰‹é‡Œä¹Ÿæœ‰ä¸€ä¸ªæ•°\\(y\\)ï¼Œå¦‚æœBobå–œæ¬¢Aliceï¼Œé‚£ä¹ˆ\\(y=1\\)ï¼Œå¦åˆ™\\(y=0\\)ã€‚\n Aliceå°†\\(x\\)ä»»æ„æ‹†æˆ\\(x=x_1\\oplus x_2\\)ï¼›åŒæ ·çš„ï¼ŒBobä¹Ÿå°†\\(y\\)ä»»æ„æ‹†æˆ\\(y=y_1\\oplus y_2\\)ã€‚\n Aliceå°†\\(x_1\\)ç•™ä¸‹ï¼Œ\\(x_2\\)å‘Šè¯‰Bobï¼›ç±»ä¼¼çš„ï¼ŒBobå°†\\(y_2\\)ç•™ä¸‹ï¼Œ\\(y_1\\)å‘Šè¯‰Aliceã€‚æ­¤æ—¶AliceçŸ¥é“\\(x_1,y_1\\)ï¼ŒBobçŸ¥é“\\(x_2,y_2\\)ã€‚\n éœ€è¦æœ‰ä¸€ä¸ªç¬¬ä¸‰æ–¹Carolï¼ŒCarolè¦éšæœºæƒ³å¥½ä¸€ä¸ªç­‰å¼\\(c=a\\land b\\)ï¼Œç„¶åå°†\\(c,x,y\\)åˆ†åˆ«æ‹†æˆ\\(c=c_1\\oplus c_2,\\ a=a_1\\oplus a_2,\\ b=b_1\\oplus b_2\\)ï¼›å°†\\(a_1,b_1,c_1\\)å‘Šè¯‰Aliceï¼Œ\\(a_2,b_2,c_2\\)å‘Šè¯‰Bobï¼ŒCarolçš„ä»»åŠ¡å°±å®Œæˆäº†ã€‚\n Aliceè®¡ç®—\\(e_1=a_1\\oplus x_1,\\ f_1=b_1\\oplus y_1\\)ï¼›åŒæ ·çš„ï¼ŒBobè®¡ç®—\\(e_2=a_2\\oplus x_2,\\ f_2=b_2\\oplus y_2\\)ã€‚ Aliceå’ŒBobå°†\\(e_1,f_1\\)å’Œ\\(e_2,f_2\\)å‘Šè¯‰å¯¹æ–¹ï¼Œä¸€èµ·è®¡ç®—\\(e=e_1\\oplus e_2,\\ f=f_1\\oplus f_2\\)ã€‚ Aliceè®¡ç®—\\(z_1 = (f\\land a_1)\\oplus (e\\land b_1)\\oplus c_1\\)ï¼›åŒæ ·çš„ï¼ŒBobè®¡ç®—\\(z_2 = (f\\land a_2)\\oplus (e\\land b_2)\\oplus c_2\\)ã€‚ æœ€åï¼ŒAliceå’ŒBobå°†\\(z_1\\)å’Œ\\(z_2\\)å‘Šè¯‰å¯¹æ–¹ï¼Œä¸€èµ·è®¡ç®—å‡º\\(z=z_1\\oplus z_2\\)ï¼Œæˆ‘ä»¬å°±å®Œæˆäº†ï¼å¦‚æœ\\(z=1\\)ï¼Œè¯´æ˜Aliceå’ŒBobäº’ç›¸å–œæ¬¢ï¼›å¦‚æœ\\(z=0\\)ï¼Œè¯´æ˜Aliceå’ŒBobå½“ä¸­è‡³å°‘æœ‰ä¸€ä¸ªäººä¸å–œæ¬¢å¯¹æ–¹ã€‚\n  åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ å®é™…ä¸Šï¼Œæˆ‘ä»¬åˆšæ‰çš„è¿‡ç¨‹å°±æ˜¯åœ¨â€œåŒæ–¹å®‰å…¨çš„è®¡ç®—ä¸¤ä¸ªæ•°çš„ä¹˜ç§¯â€ï¼Œåªä¸è¿‡æ˜¯åœ¨æ¨¡2æ„ä¹‰ä¸‹çš„å•bitå½¢å¼ã€‚\nè¿™ä¸ªé—®é¢˜å±äºå¤šæ–¹å®‰å…¨è®¡ç®—(Secure Multi-Party Computation)é¢†åŸŸï¼Œåˆšæ‰çš„è¿‡ç¨‹å®é™…ä¸Šé€šè¿‡ä¸€ç§å«åšç§˜å¯†å…±äº«(Secret Sharing)çš„æ–¹æ³•å®Œæˆçš„ã€‚\nç›´è§‚ä¸Šï¼ŒAliceç§˜å¯†å°±æ˜¯\\(a\\)ï¼Œç„¶åAliceå°†ä»–/å¥¹çš„ç§˜å¯†çš„ä¸€éƒ¨åˆ†\\(a_2\\)åˆ†äº«ç»™äº†Bobï¼›Bobä¹Ÿæ˜¯åŒç†ã€‚\næ›´å…·ä½“çš„è§£é‡Šï¼Œå¯ä»¥è‡ªè¡ŒGoogleï¼Œæˆ–è€…å‚è€ƒABYâ€“A Framework for Efficient Mixed-Protocol Secure Two-Party Computationè¿™ç¯‡æ–‡ç« çš„ç¬¬ä¸‰éƒ¨åˆ†ã€‚\nå®ƒçœŸçš„æ­£ç¡®å—ï¼Ÿ æ˜¯çœŸçš„ã€‚ä¸ä¿¡çš„è¯ï¼Œä½ å¯ä»¥é©¬ä¸Šæ‰¾èº«è¾¹çš„äººé™ªä½ ç©ä¸€ä¸‹ã€‚\nå®ƒçœŸçš„å®‰å…¨å—ï¼Ÿ åªè¦ä½ ä¸æŠŠä¸è¯¥å‘Šè¯‰å¯¹æ–¹çš„ä¸œè¥¿è¯´å‡ºå»ï¼Œå®ƒå°±æ˜¯å®‰å…¨çš„ã€‚\nå½“ç„¶äº†ï¼Œå¦‚æœCarolå’Œå¯¹æ–¹ä¸²é€šä¸€æ°”çš„è¯å°±ä¸å¥½äº†ã€‚\näº‹å®ä¸Šï¼ŒCarolå¹¶ä¸æ˜¯å¿…é¡»çš„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡Homomorphic Encryption(HE)æˆ–è€…Obilivious Transfer(OT)çš„æ–¹æ³•æ¥è®¡ç®—è¿™ä¸ªmultiplication triple \\((c_1\\oplus c_2)= (a_1\\oplus a_2)\\land (b_1\\oplus b_2)\\)ã€‚ç„¶è€Œï¼ŒHEå’ŒOTå¹¶ä¸æ˜¯èƒ½æ‰‹ç®—çš„ä¸œè¥¿ã€‚å¹¶ä¸”æ—¢ç„¶éƒ½HEäº†ï¼Œç›´æ¥ç”¨HEæ¥å®‰å…¨çš„è®¡ç®—\\(x\\land y\\)ä¸å¥½å—ğŸ™ƒ\nåè®° é‡åˆ°ç”Ÿæ´»ä¸­æœ‰è¶£çš„é—®é¢˜ï¼Œè¿˜èƒ½ä¸è¿‘æœŸå­¦çš„ä¸€äº›çŸ¥è¯†äº§ç”Ÿè”ç³»çš„æ¦‚ç‡çœŸçš„å¾ˆå°QwQã€‚\nå¸Œæœ›è¿™ä¸ªç³»åˆ—èƒ½æ´»ä¸‹å»...\n","date":1589593786,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589593786,"objectID":"a5c49233f1616eb13ca0a157ec6fed80","permalink":"thwfhk.github.io/post/do_u_like_me/","publishdate":"2020-05-16T09:49:46+08:00","relpermalink":"thwfhk.github.io/post/do_u_like_me/","section":"post","summary":" çˆ±æƒ…å…¶å®å°±æ˜¯é˜¿å¦®ç›/é˜¿å°¼å§†æ–¯åœ¨å¯¹æ–¹èº«ä¸Šçš„æŠ•å°„ã€‚\n","tags":["secret sharing","writing"],"title":"å¦‚ä½•å®‰å…¨åœ°çŸ¥é“å¯¹æ–¹æ˜¯å¦å–œæ¬¢ä½ ","type":"post"},{"authors":null,"categories":["What-is-what"],"content":" 0,1,2,3,4,....æˆ‘å¥½åƒå¯ä»¥æ— ç©·æ— å°½çš„æ•°ä¸‹å»å•Šï¼Ÿ\n è¿™æ˜¯\u0026quot;ä»€ä¹ˆæ˜¯ä»€ä¹ˆ(What is What)\u0026quot;ç³»åˆ—çš„ç¬¬ä¸€ç¯‡æ–‡ç« ï¼Œé¦–å…ˆä»‹ç»ä¸€ä¸‹è¿™ä¸ªç³»åˆ—ï¼š\næˆ‘æœ‰æ—¶ä¼šå‘ç°è‡ªå·±åœ¨ä¸åŒçš„åœ°æ–¹å­¦åˆ°çš„ä¸œè¥¿ä»¥æŸç§å¾®å¦™çš„æ–¹å¼è”ç³»åœ¨ä¸€èµ·ï¼Œè¿™ç§ä½“éªŒéå¸¸æœ‰è¶£ï¼›å¦ä¸€æ–¹é¢ï¼Œæœ‰äº›äº‹ç‰©åˆæ˜¯éš¾ä»¥ç•Œå®šçš„ï¼Œå³ä½¿è¯»å†å¤šæ¬¡å®ƒçš„å®šä¹‰ï¼Œä»ä¼šæ„Ÿåˆ°ç¢ç£¨ä¸é€ã€‚å› æ­¤ï¼Œæˆ‘å¸Œæœ›å¼€å§‹è¿™æ ·ä¸€ä¸ªç³»åˆ—ï¼Œå°†æˆ‘åœ¨ä¸åŒçš„åœ°æ–¹çœ‹åˆ°çš„åŒä¸€äº‹ç‰©æ€»ç»“åœ¨ä¸€èµ·ï¼Œå¸Œæœ›èƒ½å¤Ÿå‘ç°å®ƒä»¬ä¹‹é—´çš„æŸç§è”ç³»ï¼Œä»è€Œå¯¹äº‹ç‰©æœ¬èº«æœ‰æ›´æ¸…æ™°çš„è®¤è¯†ã€‚\nç¬¬ä¸€ä¸ªäº‹ç‰©æ˜¯â€œè‡ªç„¶æ•°(Natural Numbers)â€.\n1. è‡ªç„¶è¯­è¨€  æ¥è‡ªæ—¥å¸¸ç”Ÿæ´»å’Œä¸­å­¦æ•°å­¦ã€‚\n è‡ªç„¶æ•°å°±æ˜¯0,1,2,3,4,...è¿™æ ·æ•°ä¸‹å»å¾—åˆ°çš„æ‰€æœ‰çš„æ•°ã€‚\nè‡ªç„¶æ•°å°±æ˜¯æ‰€æœ‰çš„æ­£æ•´æ•°ï¼ŒåŒ…å«0.ï¼ˆPS: æˆ‘è‡³ä»Šè®°å¾—é«˜ä¸­æ—¶æˆ‘åˆ†ä¸æ¸…\\(\\mathbb{N}\\)ä¸­æœ‰æ²¡æœ‰0ï¼Œç„¶ååŒæ¡Œä¸€è„¸é„™å¤·çš„è¯´â€œNæ˜¯è‡ªç„¶æ•°çš„ç¼©å†™å§ï¼Œåº”è¯¥åŒ…å«0â€ï¼‰\n2. Peanoå…¬ç†  æ¥è‡ªDiscrete Mathè¯¾ç¨‹ã€‚\n Peanoå…¬ç†åˆ»ç”»äº†è‡ªç„¶æ•°é›†çš„æ€§è´¨ï¼Œæ»¡è¶³Peanoå…¬ç†çš„ç³»ç»Ÿæ˜¯è‡ªç„¶æ•°é›†ï¼ˆè‡³å°‘æ˜¯å’Œè‡ªç„¶æ•°é›†åŒæ„çš„ï¼‰ã€‚\nä¸€ç§Peanoå…¬ç†çš„æè¿°ä¸ºï¼šè®¾ä¸‰å…ƒç»„\\((N,F,0)\\)æ»¡è¶³ï¼š\n\\(0\\in N\\)\n \\(N\\) is closed under \\(F\\), i.e. \\(F(N)=\\{F(n)\\mid n\\in N\\} \\subset N\\)\n \\(0\\notin \\text{ran}\\ F\\)\n \\(F\\) is injective.\n Suppose a subset \\(A\\) of \\(N\\) satisfies \\(0\\in A\\) and \\(F(A)\\subset A\\), then \\(A=N\\).\n  è¿™æ ·\\(N\\)å°±æ˜¯è‡ªç„¶æ•°é›†ã€‚\näº‹å®ä¸Šï¼Œ\\(F\\)æŒ‡å®šäº†\\(N\\)ä¸Šçš„ä¸€ç§â€œåç»§â€è¿ç®—ï¼Œè¿™ç§åç»§è¿ç®—ç»™äº†\\(N\\)ä¸­æ¯ä¸ªå…ƒç´ ä¸€ä¸ªç‹¬ä¸€æ— äºŒçš„åç»§ï¼Œå¹¶ä¸”æ¯ä¸ªåç»§éƒ½åœ¨\\(N\\)ä¸­ï¼Œè¿™å’Œè‡ªç„¶æ•°æ˜¯ç›¸ç¬¦çš„ã€‚ç¬¬5æ¡å¯ä»¥ç®—æ˜¯â€œæœ€å…³é”®â€çš„ä¸€æ¡ï¼Œå®ƒå®é™…ä¸Šè¯´æ˜äº†è‡ªç„¶æ•°é›†\\(N\\)æ˜¯æ»¡è¶³è¿™ä¸ªæ¡ä»¶çš„æœ€å°é›†åˆã€‚\n3. é›†åˆè®º(Set Theory)  æ¥è‡ªDiscrete Mathè¯¾ç¨‹ã€‚\n è‡ªç„¶æ•°é›†æ˜¯æœ€å°çš„å½’çº³é›†(minimal inductive set).\nå…¶ä¸­ä¸€ä¸ªé›†åˆ\\(A\\)æ˜¯å½’çº³é›†(inductive set)ï¼Œå½“ä¸”ä»…å½“ï¼š\n \\(0\\in A\\) \\(\\forall a\\in A,\\ a^+\\in A\\)  å…¶ä¸­\\(a^+\\)æ˜¯\\(a\\)çš„åç»§è¿ç®—ã€‚\nå¯ä»¥å‘ç°ï¼Œè¿™ç§å®šä¹‰å’ŒPeanoå…¬ç†å‡ ä¹æ˜¯ä¸€æ ·çš„ï¼Œ\\(a^+\\)å°±æ˜¯\\(F(a)\\)ã€‚Peanoå…¬ç†ä¸­çš„ç¬¬5æ¡å®é™…ä¸Šå°±æ˜¯ä¿è¯äº†\u0026quot;\\(N\\)æ˜¯æ»¡è¶³\\(0\\in A\\land F(A)\\subset A\\)çš„æœ€å°é›†åˆ\u0026quot;ã€‚\nå¦å¤–ï¼Œåœ¨é›†åˆè®ºä¸­æœ‰ä¸€ç§å¯¹è‡ªç„¶æ•°çš„ç»å…¸æ„é€ ï¼š\n \\(0=\\{\\}\\) \\(1=\\{0\\} = \\{\\{\\}\\}\\) \\(2=\\{0,1\\}=\\{\\{\\},\\{\\{\\}\\}\\}\\) ... \\(n+1 = n\\cup \\{n\\}\\)  è¿™ç§æ„é€ çš„ä¸€ä¸ªå¥½å¤„åœ¨äº\\(a\\le b\\)å¯ä»¥è¡¨è¾¾æˆ\\(a\\subseteq b\\)ã€‚\n4. ä¸åŠ¨ç‚¹(Fixed Point)  æ¥è‡ªTypes and Programming Languages.\n è‡ªç„¶æ•°é›†æ˜¯å‡½æ•°\\(F\\)çš„æœ€å°ä¸åŠ¨ç‚¹(the least fixed point)ï¼Œå…¶ä¸­é›†åˆåˆ°é›†åˆçš„å‡½æ•°\\(F\\)å®šä¹‰ä¸ºï¼š\n \\(F(X) = \\{0\\}\\cup \\{x^+\\mid x\\in X\\}\\)  \\(F\\)çš„ä¸åŠ¨ç‚¹æ˜¯æŒ‡æ»¡è¶³\\(X=F(X)\\)çš„é›†åˆ\\(X\\)ã€‚\nè¿™ä¸ªå®šä¹‰åœ¨æœ¬è´¨ä¸Šå’Œå‰é¢æ˜¯ä¸€æ ·çš„ï¼Œåªä¸è¿‡æ˜¯ä»ä¸åŠ¨ç‚¹çš„è§’åº¦ã€‚\næœ€å°ä¸åŠ¨ç‚¹å’Œæœ€å¤§ä¸åŠ¨ç‚¹æ„é€ å¸¸ç”¨æ¥å®šä¹‰ç¨‹åºè¯­è¨€ä¸­çš„recursive datatypesï¼Œè¿™é‡Œå®é™…ä¸Šå°†â€œè‡ªç„¶æ•°é›†â€çœ‹æˆäº†â€œè‡ªç„¶æ•°ç±»å‹â€è¿™ä¸ªé€’å½’æ•°æ®ç±»å‹ã€‚\næ›´å¤šä¿¡æ¯å¯ä»¥å‚è€ƒTypes and Programming Languagesçš„21ç« ã€‚\n5. F-ä»£æ•°(F-Algebra)  æ¥è‡ªProgram Calculation.\n è®°\\(F=\\underline 1\\hat{+} Id\\)ï¼Œ\\(Nat = \\mu F\\)ï¼Œå³è‡ªç„¶æ•°é›†æ˜¯å‡½å­\\(F\\)çš„åˆå§‹ä»£æ•°çš„Carrierã€‚\\((Nat,in_F::F\\ \\mu F\\to\\mu F)\\)æ˜¯F-åˆå§‹ä»£æ•°(the initial \\(F\\)-algebra)ã€‚\nè¿™ç§ä½¿ç”¨intial F-algebraæ¥å®šä¹‰çš„æ•°æ®ç±»å‹åˆå«åšAlgebraic Datatypes.\nè¿™é‡Œä½¿ç”¨\\(Nat\\)è€Œä¸æ˜¯\\(\\mathbb{N}\\)ï¼Œæ˜¯ä¸ºäº†çœ‹èµ·æ¥æ›´åƒä¸€ä¸ªæ•°æ®ç±»å‹ï¼Œè€Œä¸æ˜¯è‡ªç„¶æ•°é›†åˆã€‚è™½ç„¶åœ¨ä½¿ç”¨\\(Set\\)èŒƒç•´çš„æ—¶å€™ï¼Œä»–ä»¬æ˜¯ä¸€æ ·çš„ã€‚\nThe initial \\((\\underline 1\\hat{+} Id)\\)-algebra æ„å‘³ç€åœ¨æŸç§æ„ä¹‰ä¸Šï¼Œ\\(Nat\\)æ˜¯å‡½å­\\((\\underline 1\\hat{+} Id)\\)çš„â€œæœ€å°ä¸åŠ¨ç‚¹â€ï¼Œå³æ»¡è¶³\\(Nat = 1+Nat\\)çš„æœ€å°é›†åˆã€‚\nåœ¨Program Calculationä¸­å€Ÿç”¨äº†èŒƒç•´è®ºçš„ä¸€äº›æ¦‚å¿µï¼Œè¿™é‡Œä¸ä¸¥æ ¼çš„ç¨ä½œè§£é‡Šï¼šæˆ‘ä»¬å–\\(Set\\)èŒƒç•´ï¼Œå¯ä»¥è®¤ä¸º\\(Set\\)ä¸­æ¯ä¸ªobjectéƒ½æ˜¯ä¸€ä¸ªç±»å‹ï¼Œæ¯ä¸ªarrowéƒ½æ˜¯å‡½æ•°ï¼ˆ\\(f:A\\to B\\)å°†ç±»å‹\\(A\\)çš„å…ƒç´ æ˜ å°„åˆ°ç±»å‹\\(B\\)çš„å…ƒç´ ï¼‰ã€‚è‡ªå‡½å­(endo-functor)å°±æ˜¯èŒƒç•´åˆ°è‡ªèº«çš„æ˜ å°„ï¼Œå°†objectså’Œarrowsæ˜ å°„åˆ°objectså’Œarrowsã€‚æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªè‡ªå‡½å­\\(F\\)ï¼Œå®ƒçš„F-algebraå®šä¹‰ä¸ºä¸€ä¸ªpair \\((A,f),\\ f::F\\ A \\to A\\) ï¼Œ\\(A\\)æ˜¯\\(Set\\)ä¸­çš„ä¸€ä¸ªobjectã€‚Initial F-algebra å°±æ˜¯\\((\\mu F, in_F)\\)ï¼Œæ»¡è¶³ä»\\((\\mu F, in_F)\\)åˆ°ä»»ä½•å…¶ä»–F-algebra \\((A,f)\\)éƒ½æœ‰ä¸€ä¸ªhomomorphismã€‚åˆ©ç”¨initial F-algebraä»¥åŠå’Œå®ƒå¯¹å¶çš„final F-algebraè¿™ä¸¤ç§æ„é€ ï¼Œå¯ä»¥å½¢å¼åŒ–çš„æè¿°fold(catamorphism)å’Œunfold(anamorphism)ã€‚\næ›´ä¸¥æ ¼çš„æè¿°å¯ä»¥å‚è€ƒCalculating Functional Programsæˆ–è€…å…¶ä»–æœ‰å…³Program Calculationçš„ææ–™ã€‚\nä¸è‡ªç„¶æ•°ä¸Šé€’å½’å®šç†çš„è”ç³» é¡ºä¾¿æä¸€ä¸‹ï¼Œä½¿ç”¨F-algebraå®šä¹‰çš„è‡ªç„¶æ•°è‡ªå¸¦äº†åˆ°å…¶ä»–F-algebraçš„å”¯ä¸€åŒæ€ï¼Œè€Œè¿™ä¸è‡ªç„¶æ•°ä¸Šçš„é€’å½’å®šç†äº§ç”Ÿäº†æŸç§è”ç³»ï¼š\nå…ˆå›é¡¾ä¸€ä¸‹è‡ªç„¶æ•°ä¸Šçš„é€’å½’å®šç†ï¼š\n è®¾é›†åˆ\\(A,\\ a\\in A,\\ F:A\\to A\\)ï¼Œåˆ™å­˜åœ¨å”¯ä¸€çš„\\(h:\\mathbb{N}\\to A\\)ï¼Œæ»¡è¶³ \\(h(0)=a\\) ä¸” \\(\\forall n\\in \\mathbb{N},\\ h(n^+) = F(h(n))\\)ã€‚  å†™æˆpoint-freeå°±æ˜¯\\(h\\circ succ = F\\circ h\\)ï¼Œå…¶ä¸­\\(succ(n) = n^+\\)\nè€Œç”±äº\\((\\mathbb{N},zero\\triangledown succ)\\)æ˜¯ä¸€ä¸ªinitial \\((\\underline 1\\hat{+} Id)\\)-algebraï¼Œæ‰€ä»¥ä»å®ƒåˆ°ä»»ä½•å…¶ä»–\\((\\underline 1\\hat{+} Id)\\)-algebra \\((A,f)\\)å­˜åœ¨å”¯ä¸€çš„åŒæ€\\(h:\\mathbb{N}\\to A\\)ï¼Œæ»¡è¶³\\(h\\circ (zero\\triangledown succ) = f\\circ (1+h)\\)\nå•Šå“ˆï¼Œå®é™…ä¸Šâ€œ\\(h\\circ (zero\\triangledown succ) = f\\circ (1+h)\\)â€ å’Œ â€œ\\(h(0)=a\\) ä¸” \\(\\forall n\\in \\mathbb{N},\\ h(n^+) = F(h(n))\\)â€ è¿™ä¸¤ä¸ªæè¿°çš„æ€§è´¨æ˜¯ä¸€æ¨¡ä¸€æ ·çš„ï¼\nè¿™ä¹ˆè¯´ï¼Œâ€œè‡ªç„¶æ•°ä¸Šçš„é€’å½’å®šç†â€ æè¿°çš„å°±æ˜¯ â€œä»ä¸€ä¸ªåˆå§‹F-ä»£æ•°åˆ°å…¶ä»–F-ä»£æ•°çš„åŒæ€â€ï¼è¿™ä¸ªåŒæ€å…¶å®å°±æ˜¯fold(catamorphism)ï¼æƒ³è¦è®¡ç®—\\(h(n)\\)ï¼Œå®é™…ä¸Šå°±æ˜¯å°†nä¸­çš„0æ¢æˆ\\(a\\)ï¼Œ\\(^+\\)æ¢æˆ\\(F\\)ã€‚\nä»è¿™é‡Œæ¨å¹¿ï¼Œå¯¹äºä»»æ„ä¸€ä¸ªalgebraic datatypeï¼Œæˆ‘ä»¬éƒ½å¯ä»¥å¾—åˆ°ä¸€ä¸ªç±»ä¼¼çš„â€œé€’å½’å®šç†â€ï¼Œå®é™…ä¸Šå°±æ˜¯catamorphismã€‚\nåè®° å…¶å®æœ¬æ¥æ˜¯è¯»Calculating Functional Programsæƒ³åˆ°çš„è¿™ä¸ªé—®é¢˜ï¼Œå›é¡¾äº†ä¸€ä¸‹Discrete Mathåå‘ç°åŸæ¥è¿˜æœ‰è¿™ä¹ˆå¤šè”ç³»ï¼Œéå¸¸æœ‰è¶£ã€‚\n","date":1589430360,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589430360,"objectID":"28ba4b2b9dda555c34879b9c7d83d51c","permalink":"thwfhk.github.io/post/natural_numbers/","publishdate":"2020-05-14T12:26:00+08:00","relpermalink":"thwfhk.github.io/post/natural_numbers/","section":"post","summary":" 0,1,2,3,4,....æˆ‘å¥½åƒå¯ä»¥æ— ç©·æ— å°½çš„æ•°ä¸‹å»å•Šï¼Ÿ\n","tags":["Set Theory","Category Theory","Programming Language Theory"],"title":"ä»€ä¹ˆæ˜¯è‡ªç„¶æ•°","type":"post"},{"authors":null,"categories":[],"content":"ä»Šå¤©çš„ä¿¡æ¯è®ºè¯¾ä¸Šè®²Kolmogorov Complexityçš„æ—¶å€™æåˆ°äº†åœæœºé—®é¢˜(Halting Problem)çš„ä¸€ç‚¹å†…å®¹ï¼Œå…¶ä¸­æœ‰è®²åˆ°åœæœºé—®é¢˜çš„è¯æ˜ã€‚\nCandy?å‘ç°åœæœºé—®é¢˜çš„è¯æ˜å’Œä¸Šå­¦æœŸç¦»æ•£æ•°å­¦è¯¾ç¨‹å­¦åˆ°çš„åº·æ‰˜å®šç†(Cantor's Theorem)çš„è¯æ˜éå¸¸åƒï¼Œäºæ˜¯æ€è€ƒäº†ä¸€ä¸‹ä»–ä»¬ä¹‹é—´çš„è”ç³»ï¼Œæ€»ç»“å¦‚ä¸‹ï¼Œä»¥æ±‚èµ¶åœ¨ä¸‰æœˆæœ«å°¾æ°´ä¸€ç¯‡åšå®¢ã€‚å¦‚æœ‰é”™è¯¯æ¬¢è¿æŒ‡å‡ºã€‚\nCantor's Theorem åº·æ‰˜å®šç†è¯´çš„æ˜¯â€œä»»ä½•é›†åˆå’Œå®ƒçš„å¹‚é›†ä¸ç­‰åŠ¿â€ï¼Œä¹Ÿå°±æ˜¯è¯´\\(A \\not\\approx P(A)\\)ã€‚\nProof: åè¯ï¼Œå‡è®¾\\(\\exists f:A\\to P(A)\\) æ˜¯ä¸€ä¸ªåŒå°„ã€‚\nè€ƒè™‘ \\(B=\\{x:x\\in A \\land x\\notin f(x)\\} \\in P(A)\\)ã€‚è®¾ \\(f(x_0) = B\\)ï¼Œè€ƒè™‘\\(x_0\\)æ˜¯å¦åœ¨\\(B\\)é›†åˆå†…ï¼š\n è‹¥\\(x_0 \\in B\\)ï¼Œåˆ™æœ‰\\(x_0 \\notin f(x_0) = B\\)ï¼Œäº§ç”ŸçŸ›ç›¾ï¼› è‹¥\\(x_0\\notin B\\)ï¼Œåˆ™æœ‰\\(x_0 \\in f(x_0) =B\\)ï¼Œäº§ç”ŸçŸ›ç›¾ã€‚  æ‰€ä»¥å¹¶ä¸å­˜åœ¨è¿™æ ·çš„åŒå°„\\(f\\)ã€‚\nHalting Problem åœæœºé—®é¢˜æ˜¯è¯´ï¼Œå¯¹äºç¨‹åº\\(P\\)åœ¨è¾“å…¥\\(I\\)ä¸‹çš„è®¡ç®—è¿‡ç¨‹\\(P(I)\\)ï¼Œå…¶æ˜¯å¦ä¼šåœ¨æœ‰é™æ­¥ç»ˆæ­¢æ˜¯ä¸å¯è®¡ç®—çš„ã€‚\nç»å…¸çš„è¯æ˜æ–¹æ³•æ˜¯è¿™æ ·çš„ï¼š\nåè¯ï¼Œå‡è®¾\\(\\exists\\ \\text{program}\\ H\\)å¯ä»¥åˆ¤å®šæ˜¯å¦ä¼šåœæœºï¼Œå³ \\[ H(P,I) = \\begin{cases} h \u0026amp; \\textrm{if $P(I)$ halts in finite steps},\\quad \\\\ l \u0026amp; \\textrm{if $P(I)$ loops forever}\\\\ \\end{cases} \\] è€ƒè™‘program \\(K\\)ï¼Œ \\[ K(P) \\begin{cases} \\text{halts in finite steps} \u0026amp; \\textrm{if $H(P,P) = l$},\\quad \\\\ \\text{loops forever} \u0026amp; \\textrm{if $H(P,P)=h$}\\\\ \\end{cases} \\] è€ƒè™‘\\(H(K,K)\\)çš„ç»“æœï¼š\n è‹¥\\(H(K,K)=h\\)ï¼Œå³\\(K(K)\\) haltsï¼Œç”±\\(K(P)\\)å®šä¹‰æœ‰\\(H(K,K)=l\\)ï¼Œäº§ç”ŸçŸ›ç›¾ï¼› è‹¥\\(H(K,K)=l\\)ï¼Œå³\\(K(K)\\) loops foreverï¼Œç”±\\(K(P)\\)å®šä¹‰æœ‰\\(H(K,K)=h\\)äº§ç”ŸçŸ›ç›¾ã€‚  æ‰€ä»¥ä¸å­˜åœ¨è¿™æ ·çš„program \\(H\\)ã€‚\nå®ƒä»¬ä¹‹é—´çš„è”ç³» ç›´è§‰ä¸Šè¿™ä¸¤ä¸ªè¯æ˜æ˜¯éå¸¸åƒçš„ã€‚\nå®é™…ä¸Šï¼Œå¯ä»¥æ”¹å†™Halting Problemçš„è¯æ˜ï¼Œå¾—åˆ°å’ŒCantor's Theoremçš„è¯æ˜ç›¸ä¼¼çš„å½¢å¼ï¼š\nåŒæ ·å‡è®¾\\(\\exists\\ \\text{program}\\ H\\)å¯ä»¥åˆ¤å®šæ˜¯å¦ä¼šåœæœºã€‚è®¾æ‰€æœ‰programçš„é›†åˆæ˜¯\\(A\\)ï¼ˆè¿™ä¸ªé›†åˆæ˜¯è‰¯å®šä¹‰çš„ï¼Œæ¯•ç«Ÿ\\(A=\\Sigma^*\\)åŠ ä¸Šä¸€ä¸ªç¡®å®šçš„è¯­æ³•æ£€æŸ¥è¿‡ç¨‹ï¼‰ï¼Œå¯¹äº\\(\\forall P\\in A\\)ï¼Œå¯ä»¥å®šä¹‰é›†åˆ\\(f(P) = \\{I : P(I)\\ \\text{halts in finite steps}\\}\\)ã€‚\\(f\\)æ˜¯ä¸€ä¸ª\\(A\\to P(A)\\)çš„æ˜ å°„ã€‚\nè€ƒè™‘\\(B=\\{P:P\\in A \\land P \\notin f(P)\\}\\)ã€‚å®¹æ˜“å‘ç°\\(B = \\{P:P\\in A \\land H(P,P) = l\\}\\)ã€‚\nåŒæ ·å®šä¹‰program \\(K\\)ï¼š \\[ K(P) \\begin{cases} \\text{halts in finite steps} \u0026amp; \\textrm{if $H(P,P) = l$},\\quad \\\\ \\text{loops forever} \u0026amp; \\textrm{if $H(P,P)=h$}\\\\ \\end{cases} \\] å®¹æ˜“éªŒè¯\\(f(K) = B\\)ï¼Œè€ƒè™‘\\(K\\)æ˜¯å¦åœ¨\\(B\\)é›†åˆå†…ï¼š\n è‹¥\\(K \\in B\\)ï¼Œåˆ™æœ‰\\(K \\notin f(K) = B\\)ï¼Œäº§ç”ŸçŸ›ç›¾ï¼› è‹¥\\(K\\notin B\\)ï¼Œåˆ™æœ‰\\(K \\in f(K) =B\\)ï¼Œäº§ç”ŸçŸ›ç›¾ã€‚  æ‰€ä»¥ä¸å­˜åœ¨è¿™æ ·çš„program \\(H\\)ã€‚\nç°åœ¨è¿™ä¸ªè¯æ˜å°±å’ŒCantor's Theoremçš„è¯æ˜ä¸€æ¨¡ä¸€æ ·äº†ï¼\nè¿™ä¸ªæ”¹å†™çš„æ ¸å¿ƒå°±æ˜¯ï¼Œå°†åŸæ¥çš„åˆ¤æ–­\\(H(P,P) = l\\)ï¼Œå˜æˆåˆ¤æ–­\\(P \\in B\\)ã€‚\nè¿˜æœ‰ä¸€ç‚¹å€¼å¾—æ³¨æ„çš„åœ°æ–¹ï¼š\n Cantor's Theoremçš„çŸ›ç›¾ç‚¹æ˜¯â€œ\\(f\\)ä¸æ˜¯åŒå°„â€ï¼Œè€Œè¿™ä¸ªè¯æ˜çš„çŸ›ç›¾ç‚¹æ˜¯â€œ\\(H\\)ä¸å­˜åœ¨â€ã€‚å…¶å®è¿™é‡Œæ˜¯ä¸€è‡´çš„ï¼ŒCantor's Theoremçš„è¯æ˜ä¸­\\(f\\)æ˜¯åŒå°„ä¿è¯äº†èƒ½æ‰¾åˆ°\\(f^{-1}(B) = x_0\\)ï¼Œè€Œè¿™ä¸ªè¯æ˜ä¸­\\(H\\)å­˜åœ¨ä¿è¯äº†èƒ½æ‰¾åˆ°\\(f^{-1}(B)=K\\)ã€‚ åœ¨æŸç§æ„ä¹‰ä¸Šâ€œ\\(H\\)å­˜åœ¨â€æ˜¯æ¯”â€œ\\(f\\)æ˜¯åŒå°„â€å¼±çš„ï¼Œå› ä¸º\\(H\\)çš„å­˜åœ¨åªèƒ½æ‰¾åˆ°\\(B\\)åœ¨æ˜ å°„ä¸‹çš„é€†ï¼Œå¯¹äºä»»æ„\\(S \\in P(A)\\)ä¸ä¸€å®šæœ‰\\(f^{-1}(S)\\)çš„å­˜åœ¨ã€‚  åè®° æœ¬æ¥è¿˜æƒ³ï¼šå¦‚æœæœ‰éªŒè¯åœæœºé—®é¢˜çš„ç¨‹åº\\(H\\)ï¼Œå°±èƒ½å¾—åˆ°\\(A\\to P(A)\\)çš„åŒå°„äº†ï¼Œç»“æœå‘ç°æƒ³çš„ä¸å¯¹ã€‚ç¨‹åºå’Œ(æ•°å­¦ä¸­)å‡½æ•°è¿™ä¸¤ä¸ªæ¦‚å¿µè¿˜æ˜¯è¦å¥½å¥½åŒºåˆ†çš„ï¼Œå‡½æ•°æ›´å¼ºå¤§ï¼Œè€Œç¨‹åºåªèƒ½ç®—æ˜¯å‡½æ•°çš„ä¸€ä¸ªå­é›†ï¼Œåªèƒ½ç»™å‡ºæŸä¸ªå¯è®¡ç®—é—®é¢˜æ‰€å¯¹åº”çš„æ˜ å°„ã€‚\nå¦å¤–ï¼Œåœæœºé—®é¢˜è¿˜ä¸lambda calculusã€å“¥å¾·å°”å®šç†ç­‰ç­‰æœ‰ç´§å¯†çš„è”ç³»ï¼Œå‘ç°äº†ä¸€ç¯‡ä¸é”™çš„blogã€‚æ°å¥½æœ€è¿‘åœ¨ä¸ŠDPPLï¼Œå¯¹lambda calculusæ¯”è¾ƒæ„Ÿå…´è¶£ï¼Œæœ‰æ—¶é—´ä»”ç»†ç ”ç©¶ä¸€ä¸‹ã€‚(å’•å’•å’•)\n","date":1585666523,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1585666523,"objectID":"af0250414f50478bf1995eef316c2fe3","permalink":"thwfhk.github.io/post/halting_problem_and_cantor_theorem/","publishdate":"2020-03-31T22:55:23+08:00","relpermalink":"thwfhk.github.io/post/halting_problem_and_cantor_theorem/","section":"post","summary":"ä»Šå¤©çš„ä¿¡æ¯è®ºè¯¾ä¸Šè®²Kolmogorov Complexityçš„æ—¶å€™æåˆ°äº†åœæœºé—®é¢˜(Halting Problem)çš„ä¸€ç‚¹å†…å®¹ï¼Œå…¶ä¸­æœ‰è®²åˆ°åœæœºé—®é¢˜çš„è¯æ˜ã€‚\n","tags":["Computation Theory","Set Theory"],"title":"åœæœºé—®é¢˜ä¸åº·æ‰˜å®šç†","type":"post"},{"authors":null,"categories":[],"content":"Candy?åœ¨ä¸Šå­¦æœŸçš„æ•°ç®—è¯¾ä¸Šå­¦äº†çº¢é»‘æ ‘ï¼Œä½†æ˜¯ä»–ä¸€ç›´æ²¡å†™è¿‡ã€‚\næœ€è¿‘ä»–å…¥é—¨äº†ä¸€ä¸‹Haskellï¼Œå¾—çŸ¥ç”¨Haskellå¯ä»¥å¾ˆæ–¹ä¾¿å®ç°å„ç§æ ‘ç»“æ„ï¼Œäºæ˜¯å°±å»å­¦äº†ä¸€ä¸‹å¦‚ä½•ç”¨Haskellå†™çº¢é»‘æ ‘ï¼Œå‘ç°åªè¦ä¸åˆ°60è¡Œï¼ï¼ˆåŒ…æ‹¬ç©ºè¡Œå’Œç±»å‹ç­¾åï¼‰\nä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„å°æ•™ç¨‹ã€‚\nPS: å…¶å®ä¸‹é¢çš„ç®—æ³•å’Œæ•°ç®—å­¦çš„é‚£ä¸ªä¸€ç‚¹å…³ç³»éƒ½æ²¡æœ‰\nå®šä¹‰ç±»å‹ å’Œæ™®é€šäºŒå‰æ ‘ä¸€æ ·å“’ï¼Œåªä¸è¿‡åŠ ä¸Šäº†ä¸€ä¸ªé¢œè‰²ä¿¡æ¯\ndata Tree a = Nil | Node Color (Tree a) a (Tree a) deriving (Show, Eq) data Color = R | B deriving (Show, Eq)  è¾…åŠ©å‡½æ•°  å°†æ ‘æ ¹æŸ“é»‘ï¼š  makeBlack :: Tree a -\u0026gt; Tree a makeBlack Nil = Nil makeBlack (Node _ l x r) = Node B l x r   å°†æ ‘æ ¹æŸ“çº¢ï¼š  makeRed :: Tree a -\u0026gt; Tree a makeRed Nil = Nil makeRed (Node _ l x r) = Node R l x r  æ’å…¥æ“ä½œ ä¸€èˆ¬çš„çº¢é»‘æ ‘æ’å…¥ä¸å¤ªæ–¹ä¾¿ç”¨çº¯å‡½æ•°å¼æ¥å†™ï¼ŒOkasakiåœ¨1999å¹´æå‡ºäº†ä¸€ç§æ–°çš„æ’å…¥æ–¹æ³•ï¼Œå°†æ’å…¥ç»Ÿä¸€ä¸ºï¼š\n é¦–å…ˆé»˜è®¤æ’å…¥çº¢è‰²èŠ‚ç‚¹ï¼Œç„¶åä»ä¸‹å‘ä¸Šè¿›è¡Œbalanceæ“ä½œï¼› balanceæ“ä½œä¼šå¤„ç†å½“å‰å­æ ‘çš„childrenå’Œgrandchildrenå‡ºç°åŒçº¢çš„æƒ…å†µï¼Œå¹¶ä¸”ä¼šå°†å½“å‰å­æ ‘çš„æ ¹å˜çº¢ï¼ˆbalanceæ“ä½œå¹¶ä¸ä¼šæ”¹å˜rankï¼‰  æ’å…¥æ“ä½œçš„æ¡†æ¶å¾ˆç®€å•ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯æœ€åè¦è®©æ•´æ£µæ ‘çš„æ ¹å˜é»‘ï¼š\ninsert :: (Ord a) =\u0026gt; a -\u0026gt; Tree a -\u0026gt; Tree a insert x = makeBlack . ins where ins Nil = Node R Nil x Nil ins t@(Node c l y r) | x \u0026lt; y = balance $ Node c (ins l) y r | x \u0026gt; y = balance $ Node c l y (ins r) | otherwise = t  balanceæ“ä½œè¦å¤„ç†å››ç§æƒ…å†µï¼š\nå¯ä»¥æ–¹ä¾¿çš„ç”¨pattern matchingæ¥å®ç°ï¼š\nbalance :: Tree a -\u0026gt; Tree a balance (Node B (Node R (Node R a x b) y c) z d) = Node R (Node B a x b) y (Node B c z d) balance (Node B (Node R a x (Node R b y c)) z d) = Node R (Node B a x b) y (Node B c z d) balance (Node B a x (Node R (Node R b y c) z d)) = Node R (Node B a x b) y (Node B c z d) balance (Node B a x (Node R b y (Node R c z d))) = Node R (Node B a x b) y (Node B c z d) balance t@(Node c x l r) = t  åˆ é™¤æ“ä½œ æ’å…¥æ“ä½œåªè¦å¤„ç†â€œåŒçº¢â€ï¼Œåˆ é™¤æ“ä½œè¿˜è¦å¤„ç†â€œé»‘è‰²èŠ‚ç‚¹æ•°ç›¸ç­‰â€ï¼Œæ¯”è¾ƒéº»çƒ¦ã€‚\nè¿™é‡Œé‡‡ç”¨äº†Stefan Kahrsåœ¨2001å¹´æå‡ºçš„æ–¹æ³•ï¼Œä¸»è¦ç‰¹ç‚¹æ˜¯ï¼š\n ä¸å°†å¾…åˆ é™¤èŠ‚ç‚¹ä¸åç»§äº¤æ¢ ç»´æŒä¸€ä¸ªæ–°çš„invariantï¼š  ä»é»‘æ ¹å­æ ‘ä¸­åˆ é™¤èŠ‚ç‚¹ï¼Œè¯¥å­æ ‘é«˜åº¦ä¼š-1 ä»çº¢æ ¹å­æ ‘ä¸­åˆ é™¤èŠ‚ç‚¹ï¼Œè¯¥å­æ ‘é«˜åº¦ä¸å˜    æˆ‘ä»¬æœ‰balanceLå’ŒbalanceRä¸¤ä¸ªæ“ä½œï¼Œåˆ†åˆ«å¤„ç†â€œå·¦å­æ ‘æ¯”å³å­æ ‘çŸ­1â€å’Œâ€œå³å­æ ‘æ¯”å·¦å­æ ‘çŸ­1â€çš„æƒ…å†µï¼Œå°†æ•´æ£µæ ‘çš„é«˜åº¦å˜æˆè¾ƒçŸ­é‚£ä¸ªçš„çŠ¶æ€ã€‚\nåˆ é™¤æ“ä½œçš„æ¡†æ¶å¦‚ä¸‹ï¼š\ndelete :: Ord a =\u0026gt; a -\u0026gt; Tree a -\u0026gt; Tree a delete x = makeBlack . del where del Nil = Nil del t@(Node _ l y r) | x \u0026lt; y = delL t | x \u0026gt; y = delR t | otherwise = app l r delL (Node _ l@(Node B _ _ _) y r) = balanceL $ Node B (del l) y r delL (Node _ l y r) = Node R (del l) y r delR (Node _ l y r@(Node B _ _ _)) = balanceR $ Node B l y (del r) delR (Node _ l y r) = Node R l y (del r)  ä»¥å¾…æ’å…¥èŠ‚ç‚¹å°†æ’å…¥å·¦å­æ ‘ä¸ºä¾‹ï¼š\n å½“å‰èŠ‚ç‚¹yçš„å·¦å­æ ‘ä¸ºé»‘æ ¹æ—¶ï¼Œä¼šåœ¨åˆ é™¤åå°†yæŸ“é»‘å¹¶è¿›è¡ŒbalanceLæ“ä½œ å½“å‰èŠ‚ç‚¹yçš„å·¦å­æ ‘ä¸ºçº¢æ ¹æ—¶ï¼Œä¼šåœ¨åˆ é™¤åå°†yæŸ“çº¢  å®¹æ˜“å‘ç°ï¼Œè¿™æ ·æ“ä½œæ˜¯å¯ä»¥ç»´æŒæ–°çš„invariantçš„ï¼ˆæšä¸¾å½“å‰èŠ‚ç‚¹é¢œè‰²æƒ…å†µè¯æ˜å³å¯ï¼‰\nç”±äºdeleteä¸­åœ¨balanceL/Rä¹‹å‰ä¼šæŸ“é»‘ï¼ŒbalanceL/Råªè¦å¤„ç†æ ¹ä¸ºé»‘çš„æƒ…å†µå³å¯ï¼Œæœ‰ä¸‰ç§æƒ…å†µï¼š\nåŒæ ·ç”¨pattern matchingæ¥å®ç°ï¼š\nbalanceL :: Tree a -\u0026gt; Tree a balanceL (Node B (Node R a x b) y r) = Node R (Node B a x b) y r balanceL (Node B l y (Node B a z b)) = balance $ Node B l y (Node R a z b) balanceL (Node B l y (Node R (Node B a u b) z c)) = Node R (Node B l y a) u (balance $ Node B b z (makeRed c)) balanceR :: Tree a -\u0026gt; Tree a balanceR (Node B l y (Node R a x b)) = Node R l y (Node B a x b) balanceR (Node B (Node B a z b) y r) = balance $ Node B (Node R a z b) y r balanceR (Node B (Node R c z (Node B a u b)) y r) = Node R (balance $ Node B (makeRed c) z a) u (Node B b y r)  appä¼šåˆå¹¶ä¸¤ä¸ªå­æ ‘ï¼Œæœ‰ä¸‰ç§æƒ…å†µï¼š\nåŒæ ·ç”¨pattern matchingæ¥å®ç°ï¼š\napp :: Tree a -\u0026gt; Tree a -\u0026gt; Tree a app Nil t = t app t Nil = t app (Node R a x b) (Node R c y d) = case app b c of Node R b' z c' -\u0026gt; Node R (Node R a x b') z (Node R c' y d) s -\u0026gt; Node R a x (Node R s y d) app (Node B a x b) (Node B c y d) = case app b c of Node r b' z c' -\u0026gt; Node R (Node B a x b') z (Node B c' y d) s -\u0026gt; balanceL $ Node B a x (Node B s y d) app (Node R a x b) t = Node R a x (app b t) app t (Node R a x b) = Node R (app t a) x b  å®Œæ•´ä»£ç  åªè¦60è¡Œï¼\ndata Tree a = Nil | Node Color (Tree a) a (Tree a) deriving (Show, Eq) data Color = R | B deriving (Show, Eq) makeBlack :: Tree a -\u0026gt; Tree a makeBlack Nil = Nil makeBlack (Node _ l x r) = Node B l x r makeRed :: Tree a -\u0026gt; Tree a makeRed Nil = Nil makeRed (Node _ l x r) = Node R l x r insert :: (Ord a) =\u0026gt; a -\u0026gt; Tree a -\u0026gt; Tree a insert x = makeBlack . ins where ins Nil = Node R Nil x Nil ins t@(Node c l y r) | x \u0026lt; y = balance $ Node c (ins l) y r | x \u0026gt; y = balance $ Node c l y (ins r) | otherwise = t balance :: Tree a -\u0026gt; Tree a balance (Node B (Node R (Node R a x b) y c) z d) = Node R (Node B a x b) y (Node B c z d) balance (Node B (Node R a x (Node R b y c)) z d) = Node R (Node B a x b) y (Node B c z d) balance (Node B a x (Node R (Node R b y c) z d)) = Node R (Node B a x b) y (Node B c z d) balance (Node B a x (Node R b y (Node R c z d))) = Node R (Node B a x b) y (Node B c z d) balance t@(Node c x l r) = t delete :: Ord a =\u0026gt; a -\u0026gt; Tree a -\u0026gt; Tree a delete x = makeBlack . del where del Nil = Nil del t@(Node _ l y r) | x \u0026lt; y = delL t | x \u0026gt; y = delR t | otherwise = app l r delL (Node _ l@(Node B _ _ _) y r) = balanceL $ Node B (del l) y r delL (Node _ l y r) = Node R (del l) y r delR (Node _ l y r@(Node B _ _ _)) = balanceR $ Node B l y (del r) delR (Node _ l y r) = Node R l y (del r) balanceL :: Tree a -\u0026gt; Tree a balanceL (Node B (Node R a x b) y r) = Node R (Node B a x b) y r balanceL (Node B l y (Node B a z b)) = balance $ Node B l y (Node R a z b) balanceL (Node B l y (Node R (Node B a u b) z c)) = Node R (Node B l y a) u (balance $ Node B b z (makeRed c)) balanceR :: Tree a -\u0026gt; Tree a balanceR (Node B l y (Node R a x b)) = Node R l y (Node B a x b) balanceR (Node B (Node B a z b) y r) = balance $ Node B (Node R a z b) y r balanceR (Node B (Node R c z (Node B a u b)) y r) = Node R (balance $ Node B (makeRed c) z a) u (Node B b y r) app :: Tree a -\u0026gt; Tree a -\u0026gt; Tree a app Nil t = t app t Nil = t app (Node R a x b) (Node R c y d) = case app b c of Node R b' z c' -\u0026gt; Node R (Node R a x b') z (Node R c' y d) s -\u0026gt; Node R a x (Node R s y d) app (Node B a x b) (Node B c y d) = case app b c of Node r b' z c' -\u0026gt; Node R (Node B a x b') z (Node B c' y d) s -\u0026gt; balanceL $ Node B a x (Node B s y d) app (Node R a x b) t = Node R a x (app b t) app t (Node R a x b) = Node R (app t a) x b  å…¶ä»–API ä¸€äº›å…¶ä»–å¸¸è§„æ“ä½œçš„APIï¼šåºåˆ—å’Œæ ‘ä¹‹é—´è½¬æ¢ã€æŸ¥æ‰¾ã€æ±‚åç»§\ntree2List :: Tree a -\u0026gt; [a] tree2List Nil = [] tree2List (Node c l x r) = tree2List l ++ [x] ++ tree2List r list2Tree :: Ord a =\u0026gt; [a] -\u0026gt; Tree a list2Tree = foldl (flip insert) Nil search :: (Ord a) =\u0026gt; a -\u0026gt; Tree a -\u0026gt; Bool search _ Nil = False search x (Node _ l y r) | x == y = True | x \u0026lt; y = search x l | otherwise = search x r successor :: Ord a =\u0026gt; a -\u0026gt; Tree a -\u0026gt; a successor x Nil = x successor x (Node _ l y r) | x \u0026lt; y = let t = successor x l in if x == t then y else t | x \u0026gt;= y = successor x r  PSï¼šå› ä¸ºæ²¡æœ‰ç»´æŠ¤sizeä¿¡æ¯æ‰€ä»¥æ²¡æ³•æ±‚ç¬¬kå°QwQï¼Œä¸è¿‡åŠ ä¸Šsizeä¿¡æ¯åº”è¯¥ä¹Ÿä¸éš¾å†™ã€‚\nå‚è€ƒèµ„æ–™  ä¸€ç¯‡è®²çš„å¾ˆå¥½çš„åšå®¢ ä¸€ä»½ä»£ç å®ç° Kahrs, Stefan. (2001). Red-black trees with types. Journal of Functional Programming. 11. 10.1017/S0956796801004026. å¦å¤–ï¼ŒMatt Mightæå‡ºäº†ä¸€ç§æ›´åŠ ç®€æ´çš„åˆ é™¤æ“ä½œçš„å®ç°ï¼Œè¯¦æƒ…å‚é˜…ä»–çš„åšå®¢ã€‚ ","date":1581406306,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1581406306,"objectID":"5f20355a85287cd3690888fbf3394aa4","permalink":"thwfhk.github.io/post/haskell_red_black_tree/","publishdate":"2020-02-11T15:31:46+08:00","relpermalink":"thwfhk.github.io/post/haskell_red_black_tree/","section":"post","summary":"Candy?åœ¨ä¸Šå­¦æœŸçš„æ•°ç®—è¯¾ä¸Šå­¦äº†çº¢é»‘æ ‘ï¼Œä½†æ˜¯ä»–ä¸€ç›´æ²¡å†™è¿‡ã€‚\n","tags":["Haskell","Algorithm"],"title":"å¦‚ä½•ç”¨Haskellå†™ä¸€æ£µçº¢é»‘æ ‘","type":"post"},{"authors":null,"categories":[],"content":"æ•…äº‹æ˜¯è¿™æ ·å¼€å§‹çš„ï¼š\nä»Šå¤©ä¸‹åˆICSè¯¾çš„æ—¶å€™æ˜•ç¥è·Ÿæˆ‘è¯´ï¼šâ€œå›½åº†èŠ‚ä¸ä¼šè¦æ”¾ä¸¤ä¸ªlabå§ï¼Œå›½åº†æ”¾å‡ å¤©å•Šâ€ã€‚\næˆ‘çœ‹äº†ä¸€ä¸‹æ ¡å†ï¼Œâ€œä»9æœˆ28å·åˆ°10æœˆ6å·ï¼Œ28ã€29ã€30ã€31ï¼ŒåŠ 6å¤©ï¼Œ10å¤©å§â€\nâ€œä½ æ€ä¹ˆåˆ¤æ–­9æœˆçš„å¤§å°çš„å•Šï¼Ÿâ€ï¼Œæ˜•ç¥è¿™æ—¶è¿˜åœ¨æ•°æ‰‹æŒ‡å…³èŠ‚åˆ¤æ–­å¤§æœˆå°æœˆã€‚\nâ€œå¥¥å¥¥ï¼Œ9æœˆæ˜¯å°æœˆå•Šï¼Œé‚£åº”è¯¥æ˜¯9å¤©â€ï¼Œæˆ‘æç„¶å¤§æ‚Ÿã€‚\nâ€œåˆ¤æ–­å¤§å°æœˆå¥½éº»çƒ¦ï¼Œä¸å¯ä»¥ç›´æ¥ç”¨å¥‡å¶æ€§â€\nâ€œä¸»è¦æ˜¯å› ä¸º7æœˆ8æœˆè¿ç»­æ˜¯å¤§æœˆï¼Œå½“åˆè®¾è®¡çš„æ—¶å€™ä¸ºä»€ä¹ˆä¸2æœˆ29å¤©ç„¶å8æœˆä¹Ÿæ˜¯å°æœˆâ€\n äºæ˜¯æˆ‘å¼€å§‹æŸ¥2æœˆåªæœ‰28å¤©çš„åŸå› ã€‚\nå¤§å¤šæ•°ä¸­æ–‡èµ„æ–™éƒ½è®²äº†è¿™æ ·ä¸€ä¸ªæ•…äº‹ï¼š\n å‡¯æ’’ä¿®æ”¹åçš„å†æ³•ä¸­2æœˆæ˜¯29å¤©çš„å¹¶ä¸”8æœˆæ˜¯30å¤©ï¼Œå±‹å¤§ç»´ç»§ä½åï¼Œä¸æ»¡è¶³äºè‡ªå·±å‡ºç”Ÿçš„8æœˆä»½åªæœ‰30å¤©äºæ˜¯ä»2æœˆä¸­æ‹¿äº†ä¸€å¤©åˆ°8æœˆã€‚\n è™½ç„¶éå¸¸å…·æœ‰æˆå‰§æ€§ï¼Œä½†è¿™ä¸ªæ•…äº‹å®åœ¨æ˜¯å¤ªä¸å¯ä¿¡ï¼Œæˆ‘åˆå»googleäº†ä¸€ä¸‹ï¼Œç»“æœ\näººå®¶æ ¹æœ¬å°±ä¸æ˜¯8æœˆå‡ºç”Ÿçš„ï¼ï¼ˆå½“ç„¶ï¼Œæœ‰å…¶ä»–ç‰ˆæœ¬çš„æ•…äº‹è¯´å±‹å¤§ç»´æ˜¯8æœˆè·å¾—å¥¥å¤æ–¯éƒ½çš„ç§°å·ï¼Œæ‰€ä»¥å°†8æœˆå˜æˆå¤§æœˆï¼Œä½†è¿™ä¹Ÿæ˜¯ä¸å¯¹çš„ï¼‰\næœ‰å¾ˆå¤šè‹±æ–‡èµ„æ–™è§£é‡Šäº†è¿™ä¸ªåŸå› ï¼Œè¯´æ³•å¤§è‡´ç›¸åŒï¼Œæ¦‚æ‹¬æ¥è¯´å°±æ˜¯ï¼š\n ç½—é©¬äººæœ€åˆåˆ°å†æ³•æ˜¯æœˆäº®å†ï¼Œå¹¶ä¸”åªæœ‰10ä¸ªæœˆï¼Œ1æœˆå’Œ2æœˆæ²¡æœ‰å‘½åï¼Œå› ä¸ºå½“æ—¶çš„ç½—é©¬äººè§‰å¾—é‚£æ®µæ—¶é—´ä¸é‡è¦ï¼ˆå¯¹è€•ç§è€Œè¨€ï¼‰ã€‚\nè¿™10ä¸ªæœˆä¸­æœ‰6ä¸ª30å¤©4ä¸ª31å¤©ï¼Œå…±304å¤©ã€‚\nåæ¥ç½—é©¬çš„ç¬¬äºŒä¸ªçš‡å¸Numaå°†1æœˆå’Œ2æœˆåŠ åˆ°äº†è¿™10ä¸ªæœˆçš„æœ€åï¼Œè®©æ€»å¤©æ•°ä¸º355å¤©ã€‚å‡ºäºå¯¹â€œå¶æ•°ä¸å‰åˆ©â€çš„è®¤è¯†ï¼Œè¿˜å°†30å¤©çš„æœˆæ”¹æˆ29å¤©ã€‚è¿™æ ·ä¸€æ¥ï¼Œå‰©ä¸‹57å¤©åˆ†ç»™ä¸¤ä¸ªæœˆï¼Œå¿…é¡»è®©1ä¸ªæœˆæ˜¯28å¤©ï¼Œäºæ˜¯å°±é€‰æ‹©äº†æœ€åä¸€ä¸ª2æœˆã€‚\nä½†æ˜¯355å¤©æ˜¾ç„¶ä¸å¯¹ï¼Œäºæ˜¯åŠ å…¥äº†â€œé—°æœˆâ€åˆ¶åº¦ã€‚\nå‡¯æ’’å³ä½åå°†å†æ³•æ”¹é©æˆå¤ªé˜³å†ï¼Œç»™ä¸€äº›æœˆåŠ äº†1åˆ°2å¤©æˆäº†30å¤©å’Œ31å¤©ï¼Œä½†ä¿ç•™äº†2æœˆè¿˜æ˜¯28å¤©ã€‚\n è€Œé‚£ç§é”™è¯¯çš„è§£é‡Šï¼Œå¯ä»¥è¿½æº¯åˆ°13ä¸–çºªSacroboscoçš„è§£é‡Šï¼Œè¯¦æƒ…å¯è§wikiä¸­çš„è¯´æ˜ã€‚è¿™ä¸ªè§£é‡Šå·²ç»è¢«è®¸å¤šå²æ–™è¯æ˜æ˜¯ä¸å¯¹çš„ã€‚\nå€¼å¾—ä¸€æçš„æ˜¯ï¼Œåœ¨å®è¡Œé—°æœˆåˆ¶åº¦çš„æ—¶å€™ï¼Œäººä»¬ä¹Ÿè®°ä¸æ¸…æ˜¯å¦é—°æœˆï¼Œéƒ½æ˜¯ç”±priestså®£å¸ƒçš„ï¼Œæ‰€ä»¥å°±ä¼šäº§ç”Ÿæ»¥ç”¨æƒåŠ›è¿›è¡Œæ—¶é—´æ”»å‡»çš„æƒ…å†µå‘ç”Ÿï¼Œæ¯”å¦‚â€œextend the terms of friends and trim the terms of enemiesâ€ï¼Œæƒ³æƒ³ä¹Ÿæ˜¯è›®é…·çš„ã€‚\n æœ€åæ€»ç»“ï¼Œè¿™ä¸ªæ•…äº‹å‘Šè¯‰æˆ‘ä»¬ï¼šæ”¾å‡çœŸå¥½ï¼\n PSï¼šä»Šå¤©æ™šä¸ŠautolabçœŸçš„ä¿®å¥½äº†ï¼Œç¬¬ä¸€ä¸ªlabä¹Ÿå‘å¸ƒäº†ï¼Œdueç«Ÿç„¶æ˜¯9æœˆ30å·ï¼Œç„¶åæˆ‘æœ¬å‘¨ç¦»æ•£ä½œä¸šè¿˜æ²¡å†™ï¼ŒwyslğŸ˜¢\n","date":1569254000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569254000,"objectID":"21001c9f098ee925adee36f597ed0505","permalink":"thwfhk.github.io/post/february/","publishdate":"2019-09-23T23:53:20+08:00","relpermalink":"thwfhk.github.io/post/february/","section":"post","summary":"æ•…äº‹æ˜¯è¿™æ ·å¼€å§‹çš„ï¼š\nä»Šå¤©ä¸‹åˆICSè¯¾çš„æ—¶å€™æ˜•ç¥è·Ÿæˆ‘è¯´ï¼šâ€œå›½åº†èŠ‚ä¸ä¼šè¦æ”¾ä¸¤ä¸ªlabå§ï¼Œå›½åº†æ”¾å‡ å¤©å•Šâ€ã€‚\n","tags":["Writing"],"title":"ä¸ºä»€ä¹ˆ2æœˆåªæœ‰28å¤©","type":"post"},{"authors":null,"categories":[],"content":"My first blog This is my new home!\nthe second title æˆ‘çˆ±ä¸­æ–‡ï¼\n$$ \\sum_{k=1}^{\\infty} \\frac{1}{k} $$\nimport CandyQwQ CandyQwQ.sayhi()   èµ°å‘éšæ™¦å’ŒæœªçŸ¥ï¼Œè¦é€šè¿‡æ›´ä¸ºéšæ™¦å’ŒæœªçŸ¥çš„äº‹ç‰©ã€‚\n ","date":1566644846,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1566644846,"objectID":"58bca268bba3f6f91e529ab15962c5b5","permalink":"thwfhk.github.io/post/first/","publishdate":"2019-08-24T19:07:26+08:00","relpermalink":"thwfhk.github.io/post/first/","section":"post","summary":"My first blog This is my new home! the second title æˆ‘çˆ±ä¸­æ–‡ï¼ $$ \\sum_{k=1}^{\\infty} \\frac{1}{k} $$ import CandyQwQ CandyQwQ.sayhi() èµ°å‘éšæ™¦å’ŒæœªçŸ¥","tags":["hello"],"title":"First","type":"post"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)   Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/media/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}   Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }   Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"thwfhk.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"thwfhk.github.io/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"6a204204d85dda77db0dd5109fd73ae2","permalink":"thwfhk.github.io/project/lambdam/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"thwfhk.github.io/project/lambdam/","section":"project","summary":"A Simple Language with Termination Checking based on Dependent Types.","tags":["Programming Language"],"title":"LambdaM","type":"project"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"4f75ccb9df9769d757f18b3f5cd19c10","permalink":"thwfhk.github.io/project/facial-filter/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"thwfhk.github.io/project/facial-filter/","section":"project","summary":"Implementation of a Real Time Facial Filter Software with GUI.","tags":["Algorithm"],"title":"Facial Filters","type":"project"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"ff6a19061a984819d30c916886db56ef","permalink":"thwfhk.github.io/publication/example/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"thwfhk.github.io/publication/example/","section":"publication","summary":"","tags":null,"title":"I have no publication yet.","type":"publication"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"cd0c5139610e946632774a6f5a6a1e11","permalink":"thwfhk.github.io/project/subgraph-isomorphism/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"thwfhk.github.io/project/subgraph-isomorphism/","section":"project","summary":"Implementation and optimization of some algorithms for the subgraph isomorphism problem.","tags":["Algorithm"],"title":"Subgraph Isomorphism","type":"project"}]