<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haskell | </title>
    <link>thwfhk.github.io/tag/haskell/</link>
      <atom:link href="thwfhk.github.io/tag/haskell/index.xml" rel="self" type="application/rss+xml" />
    <description>Haskell</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Tue, 25 Aug 2020 17:43:42 +0800</lastBuildDate>
    <image>
      <url>/thwfhk.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>Haskell</title>
      <link>thwfhk.github.io/tag/haskell/</link>
    </image>
    
    <item>
      <title>åŒºåˆ†ä¸€äº›Higher-orderå¼€å¤´çš„è¯</title>
      <link>thwfhk.github.io/post/higher_order_xxx/</link>
      <pubDate>Tue, 25 Aug 2020 17:43:42 +0800</pubDate>
      <guid>thwfhk.github.io/post/higher_order_xxx/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;æŸç§æ„ä¹‰ä¸Šï¼Œé«˜é˜¶æ„å‘³ç€ä¸€ç­‰å…¬æ°‘ï¼ˆ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;åœ¨é˜…è¯»PLç›¸å…³çš„è®ºæ–‡ä»¥åŠå‡½æ•°å¼è¯­è¨€çš„ç›¸å…³èµ„æ–™çš„æ—¶å€™ï¼Œç»å¸¸ä¼šçœ‹åˆ°&amp;quot;&lt;strong&gt;higher-order xxx&lt;/strong&gt;&amp;ldquo;æˆ–è€…&amp;rdquo;&lt;strong&gt;higher-xxx yyy&lt;/strong&gt;&amp;ldquo;è¿™ç§æ ¼å¼çš„è¯è¯­ï¼Œä»¿ä½›æ˜¯ä¸€åˆ‡ä¸œè¥¿å‰é¢éƒ½èƒ½åŠ ä¸ªhigher-orderã€‚æˆ‘æ—¶å¸¸åˆ†ä¸æ¸…ä»–ä»¬çš„å«ä¹‰ï¼Œäºæ˜¯æˆ‘æƒ³ä»è¯­è¨€çš„è§’åº¦æ€»ç»“ä¸€ä¸‹å„ç§higher/higher-orderå¼€å¤´çš„è¯è¯­ã€‚å¯ä»¥å‘ç°ä»–ä»¬ä¹‹é—´è¿˜æ˜¯å¾ˆç›¸ä¼¼çš„ã€‚&lt;/p&gt;
&lt;h2 id=&#34;higher-order-functions&#34;&gt;Higher-order Functions&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;higher-order function&lt;/strong&gt; æŒ‡æ¥å—å‡½æ•°ä½œä¸ºå‚æ•°çš„å‡½æ•°ï¼ˆæœ‰æ—¶å€™è¿”å›å‡½æ•°çš„å‡½æ•°ä¹Ÿç®—ï¼‰ï¼Œæ¯”å¦‚&lt;code&gt;map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&lt;/code&gt;ã€‚&lt;/p&gt;
&lt;p&gt;å¦‚æœæˆ‘ä»¬æŠŠtypeå†™æˆä¸€æ£µè¯­æ³•æ ‘ï¼Œå¯ä»¥å¯¹äºhigher-order functionçš„typeï¼Œå®ƒä»æ ¹èµ°åˆ°æŸä¸ª$(a\to b)$çš„è·¯å¾„ä¸Šè‡³å°‘æœ‰ä¸€æ¬¡æ˜¯&lt;strong&gt;èµ°äº†æŸä¸ª$\to$èŠ‚ç‚¹çš„å·¦è¾¹&lt;/strong&gt;ã€‚&lt;/p&gt;
&lt;p&gt;åœ¨æ”¯æŒhigher-order functionçš„è¯­è¨€ä¸­ï¼Œå‡½æ•°æ˜¯&lt;strong&gt;ä¸€ç­‰å…¬æ°‘ï¼ˆfirst-class citizenï¼‰&lt;/strong&gt;ï¼Œä¹Ÿå°±æ˜¯è¯´å‡½æ•°å¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’ã€‚ä¸¥æ ¼æ¥è¯´ä¸€ç­‰å…¬æ°‘è¿˜åº”è¯¥æ”¯æŒèµ‹å€¼ã€å­˜å‚¨ç­‰æ“ä½œï¼Œä½†æˆ‘è§‰å¾—å·²ç»æ”¯æŒä½œä¸ºå‚æ•°ä¼ é€’å’Œè¿”å›äº†ï¼Œå…¶ä»–çš„åº”è¯¥ä¹Ÿéƒ½æ”¯æŒï¼ˆçº¯ç²¹çš„å‡½æ•°å¼è¯­è¨€ä¸åœ¨æ„è¿™äº›ğŸ¶ï¼‰ã€‚&lt;/p&gt;
&lt;p&gt;å¦‚æœå‡ºç°&lt;strong&gt;higher-order language&lt;/strong&gt;è¿™ä¸ªè¯ï¼Œä¸€èˆ¬æŒ‡æ”¯æŒhigher-order functionçš„è¯­è¨€ã€‚&lt;/p&gt;
&lt;p&gt;å¯¹åº”çš„lambda calculusçš„ä¾‹å­ï¼šsimply typed lambda calculus $\lambda_\to$.&lt;/p&gt;
&lt;h2 id=&#34;higher-order-type-operators&#34;&gt;Higher-order Type (Operators)&lt;/h2&gt;
&lt;p&gt;é¦–å…ˆç®€å•ä»‹ç»ä¸€ä¸‹å…³äºtype operatorå’Œkindçš„å‰ç½®çŸ¥è¯†ï¼š&lt;/p&gt;
&lt;p&gt;æˆ‘ä»¬æƒ³è¦è®¨è®º&lt;strong&gt;type-level functions&lt;/strong&gt; (or &lt;strong&gt;type operators&lt;/strong&gt;, type constructors), æ¯”å¦‚&lt;code&gt;Ref T&lt;/code&gt; , &lt;code&gt;Pair S T&lt;/code&gt;ç­‰ç­‰ã€‚å› æ­¤åœ¨typeå±‚é¢å¼•å…¥äº†abstraction $\lambda X::K.T$ å’Œapplication $T\ T$ã€‚è¿™æ ·å°±æœ‰äº†type operatorsã€‚&lt;/p&gt;
&lt;p&gt;ä¸ºäº†ä»arityä¸ŠåŒºåˆ†type (operators)ï¼Œæˆ‘ä»¬å¼•å…¥&lt;strong&gt;kinds&lt;/strong&gt; (the types of types):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a single atomic kind $*$ (pronounced &amp;ldquo;type&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;a single constructor $\Rightarrow$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ä¸€äº›ä¾‹å­ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$*$ : the kind of &lt;strong&gt;proper types&lt;/strong&gt; (or ground types, the sorts of type expressions that are actually used to classify terms), like $Bool,\ Nat\to Nat,\ \forall X.X\to X$&lt;/li&gt;
&lt;li&gt;$*\Rightarrow &lt;em&gt;$ : the kind of &lt;strong&gt;type operators&lt;/strong&gt; (functions from proper types to proper types), like $\lambda X.T$ (abbreviation for $\lambda X::&lt;/em&gt;.T$)&lt;/li&gt;
&lt;li&gt;$* \Rightarrow * \Rightarrow *$ : the kind of functions from proper types to type operators&lt;/li&gt;
&lt;li&gt;$(* \Rightarrow *) \Rightarrow *$ : the kind of functions from type operators to proper types.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;æœ‰$*\Rightarrow \cdots \Rightarrow *$ è¿™ç§kindçš„typeç§°ä¸ºtype operatoræˆ–è€…&lt;strong&gt;first-order type operator&lt;/strong&gt;ï¼›&lt;/p&gt;
&lt;p&gt;è€Œå¦‚æœæœ‰$(*\Rightarrow *)$å‡ºç°åœ¨æŸä¸ª$\Rightarrow$çš„å·¦å­æ ‘ï¼Œè¿™ç§type operatorç§°ä¸º&lt;strong&gt;higher-order type operators&lt;/strong&gt; or &lt;strong&gt;higher-kinded type operators&lt;/strong&gt;ã€‚è¿™ä¸ªå®šä¹‰å’Œhigher-order functionæ˜¯å®Œå…¨ä¸€è‡´çš„ï¼Œåˆ«å¿˜äº†type operatoræ˜¯typeä¹‹é—´çš„functionã€‚&lt;/p&gt;
&lt;p&gt;higher-order type operatorå¾ˆå°‘å‡ºç°ã€‚&lt;/p&gt;
&lt;p&gt;å¯¹åº”çš„lambda calculusçš„ä¾‹å­ï¼š$\lambda_\omega$&lt;/p&gt;
&lt;h2 id=&#34;higher-rank-polymorphism&#34;&gt;Higher-rank Polymorphism&lt;/h2&gt;
&lt;p&gt;Polymorphismæœ‰å¾ˆå¤šç§ï¼Œhigher-rank polymorphismæ˜¯å¯¹äºparametric polymorphismæ¥è¯´çš„ã€‚&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Parametric polymorphism&lt;/strong&gt;å…è®¸åœ¨typeä¸­å‡ºç°type variableå’Œquantifier ï¼ˆå¦‚$\lambda X.t :: \forall X.T$ï¼‰ï¼Œå¹¶åœ¨evaluationæ—¶ç”¨ä¸åŒçš„typeå®ä¾‹åŒ–type variableã€‚ä»–ä¸&lt;strong&gt;ad-hoc polymorphism&lt;/strong&gt;çš„å¾ˆå¤§ä¸€ä¸ªä¸åŒåœ¨äºï¼šThe polymorphic functions act on different types &lt;em&gt;&lt;strong&gt;uniformly&lt;/strong&gt;&lt;/em&gt;. è¿™ä¹Ÿæ˜¯&lt;strong&gt;parametricity&lt;/strong&gt;(see theorem for free)çš„æ¥æºã€‚&lt;/p&gt;
&lt;p&gt;ä¸€äº›ä¾‹å­ï¼šSystem $F$ï¼ŒFPä¸­å¤§éƒ¨åˆ†è¯­è¨€ï¼Œé¢å‘å¯¹è±¡ä¸­çš„genericsï¼ŒC++ä¸­çš„templateã€‚&lt;/p&gt;
&lt;p&gt;å‡ ç§åˆ†ç±»ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;let-polymorphsim(prenex polymorphism)&lt;/strong&gt;: åªå…è®¸polymorphismå‡ºç°åœ¨top-level let-bindingsï¼Œä¹Ÿå°±æ˜¯è¯´quantifieråªèƒ½å‡ºç°åœ¨æœ€å¤–å±‚ï¼Œå› æ­¤type variablesåªèƒ½instantiateæˆquntifier-free typeã€‚åˆç§°ä¸º&lt;strong&gt;rank-1 polymorphism&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rank-2 polymorphism&lt;/strong&gt;: æŠŠtypeå†™æˆè¯­æ³•æ ‘æ ‘ï¼Œä»æ ¹åˆ°ä»»ä¸€ä¸ª$\forall$ quantifierçš„è·¯å¾„ä¸èµ°&lt;strong&gt;ä¸¤æ¬¡æˆ–ä»¥ä¸Š&lt;/strong&gt;$\to$èŠ‚ç‚¹çš„å·¦è¾¹ã€‚æ¯”å¦‚$(\forall X.X\to X)\to Nat$å°±æ˜¯èµ°äº†ä¸€æ¬¡ã€‚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rank-k polymorphism&lt;/strong&gt; (å¦‚ä¸Šç±»æ¨)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rank-n polymorphism&lt;/strong&gt;åˆç§°ä¸º&lt;strong&gt;higher-rank polymorphism&lt;/strong&gt; or impredicative (first-class) polymorphismï¼Œå…è®¸ä»»æ„å¤šæ¬¡ã€‚æ³¨æ„åˆ°ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥å°†polymorphic functionä»»æ„çš„å½“ä½œå‚æ•°è¿›è¡Œä¼ é€’ï¼Œå› æ­¤polymorphic functionå˜æˆäº†ä¸€ç­‰å…¬æ°‘ã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Haskellæ”¯æŒrank-n polymorphismï¼Œ&lt;code&gt;{-# LANGUAGE Rank2Types #-} {-# LANGUAGE Rank2Types #-}&lt;/code&gt;å®é™…ä¸Šå°±æ˜¯ç”¨æ¥å¼€å¯rank-n polymorphism. è¿™æ ·å°±å¯ä»¥å†™å‡º&lt;code&gt;f :: (forall n. n-&amp;gt;n) -&amp;gt; (Int, Double)&lt;/code&gt;è¿™ç§å‡½æ•°ã€‚æ³¨æ„å®ƒä¸&lt;code&gt;f :: forall n . (n-&amp;gt;n) -&amp;gt; (Int, Double)&lt;/code&gt;çš„åŒºåˆ«ï¼šå‰è€…æ¥å—ä¸€ä¸ªèƒ½ä½œç”¨äºä»»æ„ç±»å‹nå¹¶è¿”å›ç±»å‹nçš„å‡½æ•°ï¼Œåè€…æ¥å—çš„å‡½æ•°ä¸­næ˜¯ä»»æ„ä¸€ä¸ªå…·ä½“çš„ç±»å‹äº†ã€‚&lt;/p&gt;
&lt;p&gt;å¯¹åº”çš„lambda calculusçš„ä¾‹å­ï¼špolymorphic lambda calculus $F$ (System F)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒHaskellçš„functionå¹¶ä¸æ”¯æŒexplicit type-level abstractionï¼ˆè€ŒSystem Fä¸­æ”¯æŒï¼‰ï¼Œå› ä¸ºè¿™ä¼šä½¿type inferenceå˜æˆundecidableã€‚Haskellçš„ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ¨æ–­type variableåº”è¯¥å®ä¾‹åŒ–æˆå“ªä¸ªç±»å‹ã€‚&lt;/p&gt;
&lt;p&gt;åœ¨åŠ å…¥pragma&lt;code&gt;{-# language TypeApplications #-}&lt;/code&gt;åå¯ä»¥å†™å‡º&lt;code&gt;idInt = id @Int&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;higher-order-polymorphism&#34;&gt;Higher-order Polymorphism&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;higher-order polymorphism&lt;/strong&gt; or &lt;strong&gt;higher-kinded polymorphism&lt;/strong&gt;ä¹Ÿæ˜¯å¯¹äºparametric polymorphismæ¥è¯´çš„ï¼Œå°±æ˜¯å°†å‰ä¸¤èŠ‚æåˆ°çš„higher-kinded typeä¸higher-rank polymorphismç»“åˆåˆ°ä¸€èµ·ï¼Œå…è®¸parametric polymorphismçš„type variableéå†type operatorã€‚&lt;/p&gt;
&lt;p&gt;ä¾‹å¦‚ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Ground = Int
type FirstOrder a = Maybe a  -- a is ground
type SecondOrder c = c Int   -- c is a first-order constructor
type ThirdOrder c = c Maybe  -- c is second-order
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Haskellä¸­&lt;code&gt;fmap :: forall f. Functor f =&amp;gt; (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&lt;/code&gt;ï¼Œ&lt;code&gt;f :: *-&amp;gt;*&lt;/code&gt;æ˜¯ä¸€ä¸ªtype operatorï¼Œæ‰€ä»¥è¿™æ˜¯ä¸ªhigher-order polymorphismã€‚è¿™ä¸ªä¾‹å­ä¸­åªç”¨åˆ°äº†rank-1 polymorphismï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å†™å‡ºåŒæ—¶ç”¨åˆ°rank-2 polymorphismå’Œhigher-order polymorphismçš„ä¾‹å­ï¼š&lt;code&gt;ret :: Monad m&#39; =&amp;gt; (forall m. Monad m =&amp;gt; a -&amp;gt; m a) -&amp;gt; a -&amp;gt; m&#39; a&lt;/code&gt;ã€‚&lt;/p&gt;
&lt;p&gt;å¯¹åº”çš„lambda calculusçš„ä¾‹å­ï¼šHigher-order polymorphic lambda-calculus $F_\omega$&lt;/p&gt;
&lt;h2 id=&#34;åè®°&#34;&gt;åè®°&lt;/h2&gt;
&lt;p&gt;æœ¬æ¥æƒ³å†™parametricityç»“æœå‘ç°å‘è¶Šæ¥è¶Šå¤§ï¼Œäºæ˜¯&lt;del&gt;æ°´ç‚¹ç®€å•çš„ä¸œè¥¿&lt;/del&gt;ã€‚&lt;/p&gt;
&lt;p&gt;å¸Œæœ›æœ‰æ—¶é—´å»è®¤çœŸå­¦ä¸€ä¸‹ä»–ä»¬ä¸logicçš„è”ç³»ã€‚&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Monadæ˜¯è‡ªå‡½å­èŒƒç•´ä¸Šçš„å¹ºåŠç¾¤</title>
      <link>thwfhk.github.io/post/monad_is_a_monoid/</link>
      <pubDate>Sat, 22 Aug 2020 22:25:27 +0800</pubDate>
      <guid>thwfhk.github.io/post/monad_is_a_monoid/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;All told, monad is just a monoid in the category of endofunctors.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;è¿é¸½ä¸¤ä¸ªæœˆåç»ˆäºåœ¨å…«æœˆä»½çš„æœ«å°¾å†æ¬¡æ›´æ–°ï¼ˆå¡«å‘ï¼‰ã€‚&lt;/p&gt;
&lt;p&gt;å¯’å‡çš„æ—¶å€™å†™è¿‡ä¸€ä¸ªå…³äºâ€œHaskellä¸­monadä¸èŒƒç•´è®ºæœ‰ä»€ä¹ˆè”ç³»â€çš„æ–‡ç« ï¼Œå½“æ—¶å†™å¾—å¾ˆ&lt;del&gt;naive&lt;/del&gt;ï¼Œç°åœ¨äº†è§£çš„æ›´å¤šäº†ä¸€ç‚¹ï¼Œäºæ˜¯å†³å®šé‡å†™ä¸€ä¸‹ã€‚ä¸»è¦å‚è€ƒèµ„æ–™æ˜¯&lt;em&gt;Category Theory for Programmers&lt;/em&gt;å’Œ&lt;em&gt;Category Theory in Context&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;monads-in-haskell&#34;&gt;Monads in Haskell&lt;/h2&gt;
&lt;p&gt;é¦–å…ˆå›é¡¾ä¸€ä¸‹Haskellä¸­çš„monadã€‚&lt;/p&gt;
&lt;p&gt;Haskellä¸­çš„Monad &lt;code&gt;m&lt;/code&gt;æ˜¯ä¸€ä¸ªtypeclassï¼Œä»–æœ¬èº«æ˜¯ä¸€ä¸ªå‡½å­ï¼ˆå› æ­¤&lt;code&gt;m :: * -&amp;gt; *&lt;/code&gt;ï¼‰ï¼Œå¸¦æœ‰ä¸€äº›æ»¡è¶³ç‰¹æ®Šæ€§è´¨çš„è¿ç®—ã€‚&lt;/p&gt;
&lt;p&gt;åœ¨Haskellä¸­å¯¹monadæœ‰ä¸‰ç§ç­‰ä»·çš„å®šä¹‰ï¼Œåˆ†åˆ«ä½¿ç”¨fish, bind, joiné…åˆreturn.&lt;/p&gt;
&lt;h3 id=&#34;fish&#34;&gt;fishğŸŸ&lt;/h3&gt;
&lt;p&gt;å¯¹äºcategory $C$å’Œendofunctor $m$ï¼Œæˆ‘ä»¬å¯ä»¥å°†aåˆ°bçš„morphismsæ¢æˆ$a\to m\ b$çš„å‡½æ•°ï¼ˆè¿™æ ·çš„å‡½æ•°ç§°ä¸º&lt;strong&gt;Kleisli arrows&lt;/strong&gt;ï¼‰ï¼Œ è‹¥å¯ä»¥å®šä¹‰æ»¡è¶³æ¡ä»¶çš„compositionå’Œidentity morphismï¼Œå¾—åˆ°çš„æ–°èŒƒç•´å°±æ˜¯$C$å¯¹åº”çš„&lt;strong&gt;Kleisli category&lt;/strong&gt; $K$ ï¼Œæ­¤æ—¶ç§°$m$æ˜¯ä¸€ä¸ª&lt;strong&gt;monad&lt;/strong&gt;ã€‚&lt;/p&gt;
&lt;p&gt;åœ¨haskellä¸­æ˜¯è¿™æ ·å®šä¹‰çš„ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class Monad m where
	(&amp;gt;=&amp;gt;) :: (a -&amp;gt; m b) -&amp;gt; (b -&amp;gt; m c) -&amp;gt; (a -&amp;gt; m c) 
	return :: a -&amp;gt; m a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;æ³¨æ„åˆ°&lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt;(fish operator)å°±æ˜¯compositionï¼Œ&lt;code&gt;return&lt;/code&gt;æ˜¯identity morphismï¼ˆçš„polymorphicç‰ˆæœ¬ï¼‰ã€‚&lt;/p&gt;
&lt;p&gt;æ­¤æ—¶monad lawsååº”çš„å°±æ˜¯Kleisli categoryå¯¹compositionçš„è¦æ±‚ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;return &amp;gt;=&amp;gt; f = f -- left unit
f &amp;gt;=&amp;gt; return = f -- right unit
(f &amp;gt;=&amp;gt; g) &amp;gt;=&amp;gt; h = f &amp;gt;=&amp;gt; (g &amp;gt;=&amp;gt; h) -- associativity 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;bind&#34;&gt;bind&lt;/h3&gt;
&lt;p&gt;è§‚å¯Ÿåˆ°&lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt;ç¬¬ä¸€æ­¥å¿…å®šæ˜¯å°†&lt;code&gt;a -&amp;gt; m b&lt;/code&gt;ä½œç”¨äºaï¼Œå› æ­¤å¯ä»¥å°†ç¬¬ä¸€ä¸ª&lt;code&gt;a -&amp;gt; m b&lt;/code&gt;æ¢æˆ&lt;code&gt;m b&lt;/code&gt;ï¼Œç®€åŒ–å¾—åˆ°&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;ï¼ˆbindï¼‰ï¼Œè¿™æ˜¯haskellä¸­æ ‡å‡†çš„monadçš„å®šä¹‰ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class Monad m where
	(&amp;gt;&amp;gt;=) :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b 
	return :: a -&amp;gt; m a
(&amp;gt;&amp;gt;) :: m a -&amp;gt; m b -&amp;gt; m b
m &amp;gt;&amp;gt; k = m &amp;gt;&amp;gt;= (\_ -&amp;gt; k)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ç›´è§‚ä¸Šï¼Œbindå°†ä¸€ä¸ªæœ‰contextçš„valueç»™äº†ä¸€ä¸ª&lt;code&gt;a -&amp;gt; m b&lt;/code&gt;ç±»å‹çš„å‡½æ•°ï¼Œä»–æä¾›äº†ä¸€ç§â€œä»contexté‡Œæ‹¿å‡ºå€¼â€çš„æ–¹æ³•ã€‚&lt;/p&gt;
&lt;p&gt;ä¸fishäº’ç›¸è¡¨ç¤ºï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;f &amp;gt;=&amp;gt; g = \x -&amp;gt; f x &amp;gt;&amp;gt;= g
x &amp;gt;&amp;gt;= f = ((\_ -&amp;gt; x) &amp;gt;=&amp;gt; f) () -- one possible version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;å¯ä»¥å°†fishè¡¨ç¤ºçš„monad lawsè½¬æ¢ä¸ºç­‰ä»·çš„bindè¡¨ç¤ºçš„monad lawsï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;return x &amp;gt;&amp;gt;= f = f x
mx &amp;gt;&amp;gt;= return = mx
(mx &amp;gt;&amp;gt;= f) &amp;gt;&amp;gt;= g = mx &amp;gt;&amp;gt;= (\x -&amp;gt; f x &amp;gt;&amp;gt;= g)
-- æˆ–è€…å†™æˆ(m &amp;gt;&amp;gt;= \x -&amp;gt; f x) &amp;gt;&amp;gt;= g = m &amp;gt;&amp;gt;= (\x -&amp;gt; f x &amp;gt;&amp;gt;= g)æ›´æ¸…æ¥šä¸€ç‚¹
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;join&#34;&gt;join&lt;/h3&gt;
&lt;p&gt;è§‚å¯Ÿåˆ°æˆ‘ä»¬å¯ä»¥å€ŸåŠ©&lt;code&gt;fmap&lt;/code&gt;æ¥åº”ç”¨å‡½æ•°fï¼Œå› æ­¤åªè¦ä¸€ä¸ª&lt;code&gt;join :: m(m a) -&amp;gt; m a&lt;/code&gt;å°±å¯ä»¥å®ç°bindçš„åŠŸèƒ½ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;class Functor m =&amp;gt; Monad m where
    join :: m (m a) -&amp;gt; m a
    return :: a -&amp;gt; m a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ä¸bindäº’ç›¸è¡¨ç¤ºï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;x &amp;gt;&amp;gt;= f = join (fmap f x)
join x = x &amp;gt;&amp;gt;= id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;joinè¡¨ç¤ºçš„monad lawsåœ¨ä¸‹æ–‡ä¸­ä¼šä»Category Theoryä¸­å¯¹$\eta,\mu$çš„è¦æ±‚ä¸­æ¨å‡ºï¼Œå¯ä»¥éªŒè¯è¿™ä¸¤æ¡å’Œä¹‹å‰çš„monad lawsç­‰ä»·ã€‚&lt;/p&gt;
&lt;h3 id=&#34;do-notation&#34;&gt;do notation&lt;/h3&gt;
&lt;p&gt;doå®é™…ä¸Šæ˜¯ä¸€ä¸ªsyntactic sugar:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;do {x1 &amp;lt;- m1; x2 &amp;lt;- m2; f x1 x2} =
m1 &amp;gt;&amp;gt;= \x1 -&amp;gt; m2 &amp;gt;&amp;gt;= \x2 -&amp;gt; f x1 x2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;å¯ä»¥ç±»ä¼¼å‘½ä»¤å¼æ¥å†™å‡½æ•°å¼ã€‚&lt;/p&gt;
&lt;p&gt;ä¸Šè¿°monad lawsç”¨do notationè¡¨ç¤ºçš„è¯å°±æ˜¯ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;do {x&#39; &amp;lt;- return x; return x&#39;} = do {f x}
do {x &amp;lt;- mx; return x} = do {mx}
do {y &amp;lt;- do {x &amp;lt;- mx; f x}; g y} = do {x &amp;lt;- mx; y &amp;lt;- f x; g y}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;monads-in-category-theory&#34;&gt;Monads in Category Theory&lt;/h2&gt;
&lt;p&gt;åœ¨Category Theoryä¸­ï¼Œmonadçš„å½¢å¼åŒ–å®šä¹‰å¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;p&gt;[Def] A &lt;strong&gt;monad&lt;/strong&gt; on a category $C$ consists of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;an endofunctor $T:C\to C$&lt;/li&gt;
&lt;li&gt;a &lt;strong&gt;multiplication&lt;/strong&gt; natural transformation $\mu : T^2 \Rightarrow T$&lt;/li&gt;
&lt;li&gt;a &lt;strong&gt;unit&lt;/strong&gt; natural transformation $\eta : 1_C\Rightarrow T$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Coherence conditions: the following diagrams commute&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;thwfhk.github.io/images/monad/monad diagram.png&#34; alt=&#34;æˆªå±2020-08-18 ä¸‹åˆ8.40.09&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;æˆ‘ä»¬å‡è®¾Haskellæœ‰ä¸€ä¸ªHaskèŒƒç•´ï¼ˆobjectsæ˜¯typeï¼Œmorphimsæ˜¯functionsï¼‰çš„è¯ï¼ŒHaskellä¸­çš„monadå°±æ˜¯HaskèŒƒç•´ä¸Šçš„monadï¼Œå…¶ä¸­&lt;code&gt;return&lt;/code&gt;å°±æ˜¯$\eta$ï¼Œ&lt;code&gt;join&lt;/code&gt;å°±æ˜¯$\mu$ï¼ˆå‡†ç¡®çš„è¯´æ˜¯components $\eta_a,\mu_a$çš„polymorphicç‰ˆæœ¬ï¼‰ï¼Œä»–ä»¬éœ€è¦æ»¡è¶³çš„monad lawså°±æ˜¯$\eta,\mu$çš„ä¸¤ä¸ªå›¾äº¤æ¢ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\mu \circ T \mu  = \mu \circ \mu T$ :  &lt;code&gt;join . fmap (join) = join . join&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;$\mu \circ T \eta = \mu \circ \eta T = 1_T$  : &lt;code&gt;join . fmap (unit) = join . unit = id&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;å½“ç„¶$\eta,\mu$è¿˜è¦æ»¡è¶³ä½œä¸ºè‡ªç„¶å˜æ¢çš„coherence conditionsï¼Œä¸è¿‡è¿™ä¸¤ä¸ªæ¡ä»¶ç”±äº&lt;em&gt;&lt;strong&gt;Theorems for Free&lt;/strong&gt;&lt;/em&gt;è€Œè‡ªåŠ¨æ»¡è¶³ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;return . f = fmap f . return&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;join . fmap (fmap f) = fmap f . join&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;æ‰€ä»¥Haskellä¸­çš„monadä¸Category Theoryä¸­çš„monadæ˜¯ä¸€è‡´çš„ï¼Œæ¥ä¸‹æ¥åªè¦è§£é‡ŠCategory Theoryä¸­monadä¸ºä»€ä¹ˆæ˜¯a monoid in the endofunctor category. æˆ‘ä»¬éœ€è¦å…ˆè¡¥å……ä¸€äº›Category Theoryä¸­çš„æ¦‚å¿µã€‚&lt;/p&gt;
&lt;h2 id=&#34;monoid-and-monoidal-category&#34;&gt;Monoid and Monoidal Category&lt;/h2&gt;
&lt;h3 id=&#34;monoid&#34;&gt;Monoid&lt;/h3&gt;
&lt;p&gt;ç»å…¸çš„monoidï¼ˆå¹ºåŠç¾¤ï¼‰æ˜¯åœ¨é›†åˆä¸Šå®šä¹‰çš„ï¼Œäººå¦‚å…¶åï¼Œæœ‰ä¹˜æ³•è¿ç®—å’Œå•ä½å…ƒã€‚&lt;/p&gt;
&lt;p&gt;[Def] A &lt;strong&gt;monoid&lt;/strong&gt; is an object $M\in Set$ together with two morphisms $\mu : M\times M\to M$ and $\eta :1\to M$.&lt;/p&gt;
&lt;p&gt;Coherence conditions: the following diagrams commute&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;thwfhk.github.io/images/monad/monoid diagram.png&#34; alt=&#34;æˆªå±2020-08-18 ä¸Šåˆ10.27.32&#34; style=&#34;zoom: 50%;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;è¿™ä¸ªå®šä¹‰å’ŒæŠ½è±¡ä»£æ•°ä¸­æ˜¯ç­‰ä»·çš„ï¼Œ$\mu$ç»™å‡ºäº†ä¸€ä¸ªäºŒå…ƒè¿ç®—å¹¶æ»¡è¶³ç»“åˆå¾‹ï¼ˆå›¾1ï¼‰ï¼Œ$\eta$ç»™å‡ºäº†ä¸€ä¸ªå•ä½å…ƒï¼ˆå›¾2ï¼‰ã€‚&lt;/p&gt;
&lt;p&gt;æˆ‘ä»¬å¯ä»¥æŠŠmonoidä»Setä¸Š&lt;em&gt;&lt;strong&gt;æ¨å¹¿åˆ°å…¶ä»–categoryä¸Š&lt;/strong&gt;&lt;/em&gt;ï¼Œèƒ½åœ¨ä¸Šé¢å®šä¹‰monoidçš„categoryéœ€è¦æ»¡è¶³ä¸€å®šæ¡ä»¶ï¼Œç§°ä¸ºmonoidal categoryã€‚&lt;/p&gt;
&lt;h3 id=&#34;monoidal-category&#34;&gt;Monoidal Category&lt;/h3&gt;
&lt;p&gt;ç›´è§‚ä¸Šï¼Œè¦æƒ³åœ¨ä¸€ä¸ªcategoryä¸Šå®šä¹‰monoidï¼Œè¿™ä¸ªcategoryéœ€è¦æœ‰ä¸€ä¸ªobjectsä¹‹é—´çš„&lt;em&gt;&lt;strong&gt;product&lt;/strong&gt;&lt;/em&gt;ï¼Œè¿˜è¦èƒ½ä»æ¯ä¸ªobjectsä¸­æ‹¿å‡ºä¸€ä¸ªunit elementã€‚æˆ‘ä»¬ä¸èƒ½ä»categoryçš„objectsé‡Œæ‹¿ä¸œè¥¿ï¼Œä½†å¯ä»¥åˆ©ç”¨terminal objectåˆ°å…¶ä»–objectsçš„æ˜ å°„æ¥å–å•ä½å…ƒï¼Œæ‰€ä»¥è¿™ä¸ªcategoryè¦æœ‰ä¸€ä¸ªç±»ä¼¼&lt;em&gt;&lt;strong&gt;terminal object&lt;/strong&gt;&lt;/em&gt;çš„ä¸œè¥¿ã€‚ã€‚&lt;/p&gt;
&lt;p&gt;monoidal categoryçš„å½¢å¼åŒ–å®šä¹‰å¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;p&gt;[Def] A &lt;strong&gt;symetric monoidal category&lt;/strong&gt;$(V,\otimes,*)$ is a category $V$ together with:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a &lt;em&gt;&lt;strong&gt;bifunctor&lt;/strong&gt;&lt;/em&gt; $-\otimes-:V\times V\to V$ called &lt;strong&gt;monoidal product&lt;/strong&gt; (or tensor product)&lt;/li&gt;
&lt;li&gt;a &lt;strong&gt;unit object&lt;/strong&gt; $*$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Coherence conditions: three coherence natural isomorphisms&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;thwfhk.github.io/images/monad/monoidal cat.png&#34; alt=&#34;æˆªå±2020-08-18 ä¸Šåˆ10.31.38&#34; style=&#34;zoom:50%;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Remarks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;æ³¨æ„$\alpha$è¿™äº›natural isomorphismsæ˜¯multifunctorsä¹‹é—´çš„ï¼Œä»–çš„componentsæ˜¯$\alpha_{u,v,w}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ä¸‰ä¸ªcoherence conditionsåˆ†åˆ«æ˜¯symetric, associativity, unit conditions on the monoidal product. åªæ»¡è¶³åä¸¤ä¸ªçš„è¯ç§°ä¸º&lt;strong&gt;monoidal category&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;å¦‚æœè¿™äº›natural isomorphismså¯ä»¥å–identity natural isomorphismsçš„è¯ï¼Œç§°ä¸º&lt;strong&gt;strict monoidal category&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All categories with ï¬nite products such as $(Set,\times, * ), (Top,\times,*),(Cat,\times,1)$, where the monoidal unit in each case is the terminal object. å¯¹å¶åœ°ï¼Œfinite coproductå’Œinitial objectä¹Ÿæ„æˆsymmetric monoidal categoryï¼Œå¦‚$(Set,+,{})$.&lt;/li&gt;
&lt;li&gt;HaskèŒƒç•´å¯ä»¥è¿‘ä¼¼çœ‹æˆSetï¼Œå› æ­¤productï¼ˆcoproductï¼‰åœ¨åŒæ„æ„ä¹‰ä¸‹æ»¡è¶³æ¡ä»¶ï¼Œterminal objectæ˜¯&lt;code&gt;()&lt;/code&gt;ï¼ˆ&lt;code&gt;Empty&lt;/code&gt;ï¼‰ï¼Œå› æ­¤Haskæ˜¯monoidal categoryã€‚&lt;/li&gt;
&lt;li&gt;A commutative monoidçœ‹ä½œdiscrete category(å³åªæœ‰identity morphisms)çš„è¯ä¹Ÿå®šä¹‰äº†ä¸€ä¸ªsymetric monoidal categoryï¼Œæ­¤æ—¶natural isomorphismså°±æ˜¯identitiesã€‚å¦ä¸€æ–¹é¢ï¼Œç»å…¸çš„monoidå°±æ˜¯Setä¸Šçš„monoidã€‚&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;monoid-in-a-monoidal-category&#34;&gt;Monoid in a Monoidal Category&lt;/h3&gt;
&lt;p&gt;åœ¨monoidal category$(V,\otimes,*)$ä¸Šå®šä¹‰monoidï¼Œæˆ‘ä»¬éœ€è¦å–ä¸€ä¸ªobject $M\in V$ä»¥åŠä¸¤ä¸ªmorphisms $\mu : M\otimes M\to M$, $\eta : * \to M$. Coherence conditionså’Œç»å…¸monoidç›¸åŒã€‚&lt;/p&gt;
&lt;h2 id=&#34;monad-as-a-monoid&#34;&gt;Monad as a Monoid&lt;/h2&gt;
&lt;p&gt;ç»ˆäºæ¥åˆ°äº†æ­£é¢˜ã€‚å®é™…ä¸Šç»è¿‡å‰é¢çš„é“ºå«ï¼Œå‰©ä¸‹çš„å†…å®¹å°±å¾ˆç®€å•äº†ï¼š&lt;/p&gt;
&lt;p&gt;æˆ‘ä»¬è€ƒè™‘&lt;strong&gt;functor category $C^C$&lt;/strong&gt;ï¼Œå®ƒçš„objectsæ˜¯functorsï¼Œmorphismsæ˜¯natural transformationsã€‚å®ƒæ˜¯ä¸€ä¸ª&lt;em&gt;&lt;strong&gt;strict monoidal category&lt;/strong&gt;&lt;/em&gt;ï¼Œmonoidal productæ˜¯&lt;em&gt;composition between functors&lt;/em&gt;ï¼Œunit objectæ˜¯identity endofunctorã€‚æ³¨æ„æ­¤æ—¶composition(ä¸€èˆ¬çœç•¥è¿ç®—ç¬¦) $-\circ -:C^C \times C^C \to C^C$æ˜¯ä¸€ä¸ªbifunctorï¼Œå®ƒæ˜¯å¯ä»¥ä½œç”¨äºnatural transformationçš„ï¼Œä½œç”¨æ•ˆæœå°±æ˜¯natural transformationçš„&lt;em&gt;&lt;strong&gt;horizontal composition&lt;/strong&gt;&lt;/em&gt;ã€‚&lt;/p&gt;
&lt;p&gt;é‚£ä¹ˆ$C^C$ä¸Šçš„monoidæ˜¯ä»€ä¹ˆæ ·çš„å‘¢ï¼Ÿå–object $T\in C^C$ï¼Œmorphisms $\mu,\eta\in C^C$æ»¡è¶³æ¡ä»¶ã€‚ $T$å°±æ˜¯ä¸€ä¸ªmonadï¼æ‰€ä»¥&lt;em&gt;A monad on $C$ is a monoid in the monoidal category $C^C$ of endofunctors on $C$&lt;/em&gt;. Bingo!&lt;/p&gt;
&lt;h2 id=&#34;åè®°&#34;&gt;åè®°&lt;/h2&gt;
&lt;p&gt;å…¶å®è¿™ç¯‡æ–‡ç« ä¸€ç‚¹ä¹Ÿä¸å‹å¥½ï¼Œ&lt;del&gt;åªèƒ½ä½œä¸ºç»™è‡ªå·±çœ‹çš„å¤ä¹ ç¬”è®°&lt;/del&gt;ã€‚&lt;/p&gt;
&lt;p&gt;monadç›¸å…³è¿˜æœ‰å¥½å¤šæœ‰è¶£çš„å†…å®¹ï¼Œæ¯”å¦‚comonadã€adjunctionsç­‰ç­‰ï¼Œ&lt;del&gt;æœ‰æ—¶é—´ä¸€å®šå†™&lt;/del&gt;ã€‚&lt;/p&gt;
&lt;p&gt;å¸Œæœ›ä»¥åå¤šæ›´æ–°ä¸€ç‚¹æœ‰è¶£çš„ä¸œè¥¿ï¼ˆå–‚è‡³å°‘åšåˆ°æœˆæ›´å•Š&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>å¦‚ä½•ç”¨Haskellå†™ä¸€æ£µçº¢é»‘æ ‘</title>
      <link>thwfhk.github.io/post/haskell_red_black_tree/</link>
      <pubDate>Tue, 11 Feb 2020 15:31:46 +0800</pubDate>
      <guid>thwfhk.github.io/post/haskell_red_black_tree/</guid>
      <description>&lt;p&gt;Candy?åœ¨ä¸Šå­¦æœŸçš„æ•°ç®—è¯¾ä¸Šå­¦äº†çº¢é»‘æ ‘ï¼Œä½†æ˜¯ä»–ä¸€ç›´æ²¡å†™è¿‡ã€‚&lt;/p&gt;
&lt;p&gt;æœ€è¿‘ä»–å…¥é—¨äº†ä¸€ä¸‹Haskellï¼Œå¾—çŸ¥ç”¨Haskellå¯ä»¥å¾ˆæ–¹ä¾¿å®ç°å„ç§æ ‘ç»“æ„ï¼Œäºæ˜¯å°±å»å­¦äº†ä¸€ä¸‹å¦‚ä½•ç”¨Haskellå†™çº¢é»‘æ ‘ï¼Œå‘ç°åªè¦ä¸åˆ°60è¡Œï¼ï¼ˆåŒ…æ‹¬ç©ºè¡Œå’Œç±»å‹ç­¾åï¼‰&lt;/p&gt;
&lt;p&gt;ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„å°æ•™ç¨‹ã€‚&lt;/p&gt;
&lt;p&gt;&lt;del&gt;PS: å…¶å®ä¸‹é¢çš„ç®—æ³•å’Œæ•°ç®—å­¦çš„é‚£ä¸ªä¸€ç‚¹å…³ç³»éƒ½æ²¡æœ‰&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&#34;å®šä¹‰ç±»å‹&#34;&gt;å®šä¹‰ç±»å‹&lt;/h2&gt;
&lt;p&gt;å’Œæ™®é€šäºŒå‰æ ‘ä¸€æ ·å“’ï¼Œåªä¸è¿‡åŠ ä¸Šäº†ä¸€ä¸ªé¢œè‰²ä¿¡æ¯&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Tree a = Nil | Node Color (Tree a) a (Tree a) deriving (Show, Eq)
data Color = R | B deriving (Show, Eq)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;è¾…åŠ©å‡½æ•°&#34;&gt;è¾…åŠ©å‡½æ•°&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;å°†æ ‘æ ¹æŸ“é»‘ï¼š&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;makeBlack :: Tree a -&amp;gt; Tree a
makeBlack Nil = Nil
makeBlack (Node _ l x r) = Node B l x r
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;å°†æ ‘æ ¹æŸ“çº¢ï¼š&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;makeRed :: Tree a -&amp;gt; Tree a
makeRed Nil = Nil
makeRed (Node _ l x r) = Node R l x r
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;æ’å…¥æ“ä½œ&#34;&gt;æ’å…¥æ“ä½œ&lt;/h2&gt;
&lt;p&gt;ä¸€èˆ¬çš„çº¢é»‘æ ‘æ’å…¥ä¸å¤ªæ–¹ä¾¿ç”¨çº¯å‡½æ•°å¼æ¥å†™ï¼Œ&lt;em&gt;Okasakiåœ¨1999å¹´æå‡ºäº†ä¸€ç§æ–°çš„æ’å…¥æ–¹æ³•&lt;/em&gt;ï¼Œå°†æ’å…¥ç»Ÿä¸€ä¸ºï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;é¦–å…ˆé»˜è®¤æ’å…¥çº¢è‰²èŠ‚ç‚¹ï¼Œç„¶åä»ä¸‹å‘ä¸Šè¿›è¡Œbalanceæ“ä½œï¼›&lt;/li&gt;
&lt;li&gt;balanceæ“ä½œä¼šå¤„ç†&lt;strong&gt;å½“å‰å­æ ‘çš„childrenå’Œgrandchildren&lt;/strong&gt;å‡ºç°åŒçº¢çš„æƒ…å†µï¼Œå¹¶ä¸”ä¼š&lt;strong&gt;å°†å½“å‰å­æ ‘çš„æ ¹å˜çº¢&lt;/strong&gt;ï¼ˆbalanceæ“ä½œå¹¶ä¸ä¼šæ”¹å˜rankï¼‰&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;æ’å…¥æ“ä½œçš„æ¡†æ¶å¾ˆç®€å•ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯æœ€åè¦è®©æ•´æ£µæ ‘çš„æ ¹å˜é»‘ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;insert :: (Ord a) =&amp;gt; a -&amp;gt; Tree a -&amp;gt; Tree a
insert x = makeBlack . ins 
  where ins Nil = Node R Nil x Nil
        ins t@(Node c l y r) | x &amp;lt; y     = balance $ Node c (ins l) y r
                             | x &amp;gt; y     = balance $ Node c l y (ins r)
                             | otherwise = t
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;balanceæ“ä½œè¦å¤„ç†å››ç§æƒ…å†µï¼š&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;thwfhk.github.io/images/haskell_rbt/rbt1.jpg&#34; alt=&#34;rbt1&#34;&gt;&lt;/p&gt;
&lt;p&gt;å¯ä»¥æ–¹ä¾¿çš„ç”¨pattern matchingæ¥å®ç°ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;balance :: Tree a -&amp;gt; Tree a
balance (Node B (Node R (Node R a x b) y c) z d) = Node R (Node B a x b) y (Node B c z d)
balance (Node B (Node R a x (Node R b y c)) z d) = Node R (Node B a x b) y (Node B c z d)
balance (Node B a x (Node R (Node R b y c) z d)) = Node R (Node B a x b) y (Node B c z d)
balance (Node B a x (Node R b y (Node R c z d))) = Node R (Node B a x b) y (Node B c z d)
balance t@(Node c x l r) = t
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;åˆ é™¤æ“ä½œ&#34;&gt;åˆ é™¤æ“ä½œ&lt;/h2&gt;
&lt;p&gt;æ’å…¥æ“ä½œåªè¦å¤„ç†â€œåŒçº¢â€ï¼Œåˆ é™¤æ“ä½œè¿˜è¦å¤„ç†â€œé»‘è‰²èŠ‚ç‚¹æ•°ç›¸ç­‰â€ï¼Œæ¯”è¾ƒéº»çƒ¦ã€‚&lt;/p&gt;
&lt;p&gt;è¿™é‡Œé‡‡ç”¨äº†&lt;em&gt;Stefan Kahrsåœ¨2001å¹´æå‡ºçš„æ–¹æ³•&lt;/em&gt;ï¼Œä¸»è¦ç‰¹ç‚¹æ˜¯ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ä¸&lt;/strong&gt;å°†å¾…åˆ é™¤èŠ‚ç‚¹ä¸åç»§äº¤æ¢&lt;/li&gt;
&lt;li&gt;ç»´æŒä¸€ä¸ª&lt;strong&gt;æ–°çš„invariant&lt;/strong&gt;ï¼š
&lt;ul&gt;
&lt;li&gt;ä»é»‘æ ¹å­æ ‘ä¸­åˆ é™¤èŠ‚ç‚¹ï¼Œè¯¥å­æ ‘é«˜åº¦ä¼š-1&lt;/li&gt;
&lt;li&gt;ä»çº¢æ ¹å­æ ‘ä¸­åˆ é™¤èŠ‚ç‚¹ï¼Œè¯¥å­æ ‘é«˜åº¦ä¸å˜&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;æˆ‘ä»¬æœ‰balanceLå’ŒbalanceRä¸¤ä¸ªæ“ä½œï¼Œåˆ†åˆ«å¤„ç†â€œå·¦å­æ ‘æ¯”å³å­æ ‘çŸ­1â€å’Œâ€œå³å­æ ‘æ¯”å·¦å­æ ‘çŸ­1â€çš„æƒ…å†µï¼Œå°†æ•´æ£µæ ‘çš„é«˜åº¦å˜æˆ&lt;strong&gt;è¾ƒçŸ­&lt;/strong&gt;é‚£ä¸ªçš„çŠ¶æ€ã€‚&lt;/p&gt;
&lt;p&gt;åˆ é™¤æ“ä½œçš„æ¡†æ¶å¦‚ä¸‹ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;delete :: Ord a =&amp;gt; a -&amp;gt; Tree a -&amp;gt; Tree a
delete x = makeBlack . del
  where
    del Nil = Nil
    del t@(Node _ l y r) | x &amp;lt; y     = delL t
                         | x &amp;gt; y     = delR t
                         | otherwise = app l r
    delL (Node _ l@(Node B _ _ _) y r) = balanceL $ Node B (del l) y r
    delL (Node _ l y r)                = Node R (del l) y r
    delR (Node _ l y r@(Node B _ _ _)) = balanceR $ Node B l y (del r)
    delR (Node _ l y r)                = Node R l y (del r)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ä»¥å¾…æ’å…¥èŠ‚ç‚¹å°†æ’å…¥å·¦å­æ ‘ä¸ºä¾‹ï¼š&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;å½“å‰èŠ‚ç‚¹yçš„å·¦å­æ ‘ä¸ºé»‘æ ¹æ—¶ï¼Œä¼šåœ¨åˆ é™¤åå°†yæŸ“é»‘å¹¶è¿›è¡ŒbalanceLæ“ä½œ&lt;/li&gt;
&lt;li&gt;å½“å‰èŠ‚ç‚¹yçš„å·¦å­æ ‘ä¸ºçº¢æ ¹æ—¶ï¼Œä¼šåœ¨åˆ é™¤åå°†yæŸ“çº¢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;å®¹æ˜“å‘ç°ï¼Œè¿™æ ·æ“ä½œæ˜¯å¯ä»¥ç»´æŒæ–°çš„invariantçš„ï¼ˆæšä¸¾å½“å‰èŠ‚ç‚¹é¢œè‰²æƒ…å†µè¯æ˜å³å¯ï¼‰&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;ç”±äºdeleteä¸­åœ¨balanceL/Rä¹‹å‰ä¼šæŸ“é»‘ï¼ŒbalanceL/Råªè¦å¤„ç†æ ¹ä¸ºé»‘çš„æƒ…å†µå³å¯ï¼Œæœ‰ä¸‰ç§æƒ…å†µï¼š&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;thwfhk.github.io/images/haskell_rbt/rbt2.jpg&#34; alt=&#34;rbt2&#34;&gt;&lt;/p&gt;
&lt;p&gt;åŒæ ·ç”¨pattern matchingæ¥å®ç°ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;balanceL :: Tree a -&amp;gt; Tree a 
balanceL (Node B (Node R a x b) y r) = Node R (Node B a x b) y r
balanceL (Node B l y (Node B a z b)) = balance $ Node B l y (Node R a z b)
balanceL (Node B l y (Node R (Node B a u b) z c)) = Node R (Node B l y a) u (balance $ Node B b z (makeRed c))

balanceR :: Tree a -&amp;gt; Tree a 
balanceR (Node B l y (Node R a x b)) = Node R l y (Node B a x b)
balanceR (Node B (Node B a z b) y r) = balance $ Node B (Node R a z b) y r
balanceR (Node B (Node R c z (Node B a u b)) y r) = Node R (balance $ Node B (makeRed c) z a) u (Node B b y r)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;appä¼šåˆå¹¶ä¸¤ä¸ªå­æ ‘ï¼Œæœ‰ä¸‰ç§æƒ…å†µï¼š&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;thwfhk.github.io/images/haskell_rbt/rbt3.jpg&#34; alt=&#34;rbt3&#34;&gt;&lt;/p&gt;
&lt;p&gt;åŒæ ·ç”¨pattern matchingæ¥å®ç°ï¼š&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;app :: Tree a -&amp;gt; Tree a -&amp;gt; Tree a
app Nil t = t
app t Nil = t 
app (Node R a x b) (Node R c y d) = 
  case app b c of
    Node R b&#39; z c&#39; -&amp;gt; Node R (Node R a x b&#39;) z (Node R c&#39; y d)
    s -&amp;gt; Node R a x (Node R s y d)
app (Node B a x b) (Node B c y d) =
  case app b c of
    Node r b&#39; z c&#39; -&amp;gt; Node R (Node B a x b&#39;) z (Node B c&#39; y d)
    s -&amp;gt; balanceL $ Node B a x (Node B s y d)
app (Node R a x b) t = Node R a x (app b t)
app t (Node R a x b) = Node R (app t a) x b
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;å®Œæ•´ä»£ç &#34;&gt;å®Œæ•´ä»£ç &lt;/h2&gt;
&lt;p&gt;åªè¦60è¡Œï¼&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;data Tree a = Nil | Node Color (Tree a) a (Tree a) deriving (Show, Eq)
data Color = R | B deriving (Show, Eq)

makeBlack :: Tree a -&amp;gt; Tree a
makeBlack Nil = Nil
makeBlack (Node _ l x r) = Node B l x r

makeRed :: Tree a -&amp;gt; Tree a
makeRed Nil = Nil
makeRed (Node _ l x r) = Node R l x r

insert :: (Ord a) =&amp;gt; a -&amp;gt; Tree a -&amp;gt; Tree a
insert x = makeBlack . ins 
  where ins Nil = Node R Nil x Nil
        ins t@(Node c l y r) | x &amp;lt; y     = balance $ Node c (ins l) y r
                             | x &amp;gt; y     = balance $ Node c l y (ins r)
                             | otherwise = t

balance :: Tree a -&amp;gt; Tree a
balance (Node B (Node R (Node R a x b) y c) z d) = Node R (Node B a x b) y (Node B c z d)
balance (Node B (Node R a x (Node R b y c)) z d) = Node R (Node B a x b) y (Node B c z d)
balance (Node B a x (Node R (Node R b y c) z d)) = Node R (Node B a x b) y (Node B c z d)
balance (Node B a x (Node R b y (Node R c z d))) = Node R (Node B a x b) y (Node B c z d)
balance t@(Node c x l r) = t

delete :: Ord a =&amp;gt; a -&amp;gt; Tree a -&amp;gt; Tree a
delete x = makeBlack . del
  where
    del Nil = Nil
    del t@(Node _ l y r) | x &amp;lt; y     = delL t
                         | x &amp;gt; y     = delR t
                         | otherwise = app l r
    delL (Node _ l@(Node B _ _ _) y r) = balanceL $ Node B (del l) y r
    delL (Node _ l y r)                = Node R (del l) y r
    delR (Node _ l y r@(Node B _ _ _)) = balanceR $ Node B l y (del r)
    delR (Node _ l y r)                = Node R l y (del r)

balanceL :: Tree a -&amp;gt; Tree a 
balanceL (Node B (Node R a x b) y r) = Node R (Node B a x b) y r
balanceL (Node B l y (Node B a z b)) = balance $ Node B l y (Node R a z b)
balanceL (Node B l y (Node R (Node B a u b) z c)) = Node R (Node B l y a) u (balance $ Node B b z (makeRed c))

balanceR :: Tree a -&amp;gt; Tree a 
balanceR (Node B l y (Node R a x b)) = Node R l y (Node B a x b)
balanceR (Node B (Node B a z b) y r) = balance $ Node B (Node R a z b) y r
balanceR (Node B (Node R c z (Node B a u b)) y r) = Node R (balance $ Node B (makeRed c) z a) u (Node B b y r)

app :: Tree a -&amp;gt; Tree a -&amp;gt; Tree a
app Nil t = t
app t Nil = t 
app (Node R a x b) (Node R c y d) = 
  case app b c of
    Node R b&#39; z c&#39; -&amp;gt; Node R (Node R a x b&#39;) z (Node R c&#39; y d)
    s -&amp;gt; Node R a x (Node R s y d)
app (Node B a x b) (Node B c y d) =
  case app b c of
    Node r b&#39; z c&#39; -&amp;gt; Node R (Node B a x b&#39;) z (Node B c&#39; y d)
    s -&amp;gt; balanceL $ Node B a x (Node B s y d)
app (Node R a x b) t = Node R a x (app b t)
app t (Node R a x b) = Node R (app t a) x b
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;å…¶ä»–api&#34;&gt;å…¶ä»–API&lt;/h2&gt;
&lt;p&gt;ä¸€äº›å…¶ä»–å¸¸è§„æ“ä½œçš„APIï¼šåºåˆ—å’Œæ ‘ä¹‹é—´è½¬æ¢ã€æŸ¥æ‰¾ã€æ±‚åç»§&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-haskell&#34;&gt;tree2List :: Tree a -&amp;gt; [a]
tree2List Nil = []
tree2List (Node c l x r) = tree2List l ++ [x] ++ tree2List r

list2Tree :: Ord a =&amp;gt; [a] -&amp;gt; Tree a
list2Tree = foldl (flip insert) Nil 

search :: (Ord a) =&amp;gt; a -&amp;gt; Tree a -&amp;gt; Bool
search _ Nil = False
search x (Node _ l y r) 
  | x == y    = True
  | x &amp;lt; y     = search x l
  | otherwise = search x r

successor :: Ord a =&amp;gt; a -&amp;gt; Tree a -&amp;gt; a
successor x Nil = x
successor x (Node _ l y r) 
  | x &amp;lt;  y = let t = successor x l in if x == t then y else t
  | x &amp;gt;= y = successor x r
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PSï¼šå› ä¸ºæ²¡æœ‰ç»´æŠ¤sizeä¿¡æ¯æ‰€ä»¥æ²¡æ³•æ±‚ç¬¬kå°QwQï¼Œä¸è¿‡åŠ ä¸Šsizeä¿¡æ¯åº”è¯¥ä¹Ÿä¸éš¾å†™ã€‚&lt;/p&gt;
&lt;h2 id=&#34;å‚è€ƒèµ„æ–™&#34;&gt;å‚è€ƒèµ„æ–™&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://abhiroop.github.io/Haskell-Red-Black-Tree/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ä¸€ç¯‡è®²çš„å¾ˆå¥½çš„åšå®¢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cs.kent.ac.uk/people/staff/smk/redblack/Untyped.hs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ä¸€ä»½ä»£ç å®ç°&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kahrs, Stefan. (2001). Red-black trees with types. Journal of Functional Programming. 11. 10.1017/S0956796801004026.&lt;/li&gt;
&lt;li&gt;å¦å¤–ï¼ŒMatt Mightæå‡ºäº†ä¸€ç§æ›´åŠ ç®€æ´çš„åˆ é™¤æ“ä½œçš„å®ç°ï¼Œè¯¦æƒ…å‚é˜…&lt;a href=&#34;http://matt.might.net/articles/red-black-delete/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ä»–çš„åšå®¢&lt;/a&gt;ã€‚&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
